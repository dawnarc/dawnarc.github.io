<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 玄冬Wong</title>
    <link>https://dawnarc.com/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 15 Dec 2019 00:31:40 +0800</lastBuildDate>
    
	<atom:link href="https://dawnarc.com/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;]Template Parameters Checking</title>
      <link>https://dawnarc.com/2019/12/c-template-parameters-checking/</link>
      <pubDate>Sun, 15 Dec 2019 00:31:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/12/c-template-parameters-checking/</guid>
      <description>&lt;p&gt;keywords: C++ Template Parameters Checking&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to use a struct as key in a std map</title>
      <link>https://dawnarc.com/2019/09/c-how-to-use-a-struct-as-key-in-a-std-map/</link>
      <pubDate>Mon, 09 Sep 2019 16:38:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/09/c-how-to-use-a-struct-as-key-in-a-std-map/</guid>
      <description>&lt;p&gt;keywords: C++, std map, struct as key&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Byte Alignment (pack pragma)</title>
      <link>https://dawnarc.com/2019/09/c-byte-alignment-pack-pragma/</link>
      <pubDate>Fri, 06 Sep 2019 15:36:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/09/c-byte-alignment-pack-pragma/</guid>
      <description>&lt;p&gt;keywords: C++, Byte Alignment, pack pragma&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Execution Order of Constructor and Deconstrutor in Inheritance</title>
      <link>https://dawnarc.com/2019/07/c-execution-order-of-constructor-and-deconstrutor-in-inheritance/</link>
      <pubDate>Thu, 25 Jul 2019 21:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-execution-order-of-constructor-and-deconstrutor-in-inheritance/</guid>
      <description>&lt;p&gt;keywords: C++, Constructor, Deconstrutor&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How Are Virtual Functions Implemented At a Deep Level</title>
      <link>https://dawnarc.com/2019/07/c-how-are-virtual-functions-implemented-at-a-deep-level/</link>
      <pubDate>Thu, 25 Jul 2019 18:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-how-are-virtual-functions-implemented-at-a-deep-level/</guid>
      <description>&lt;p&gt;keywords: Virtual Functions, VTables&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Pure LLVM(Clang) Compilation Libraries</title>
      <link>https://dawnarc.com/2019/07/c-pure-llvmclang-compilation-libraries/</link>
      <pubDate>Sun, 07 Jul 2019 14:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-pure-llvmclang-compilation-libraries/</guid>
      <description>&lt;p&gt;keywords: LLVM Clang Compilation Library&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Clang Compilation Error - expected unqualified-id</title>
      <link>https://dawnarc.com/2019/07/c-clang-compilation-error-expected-unqualified-id/</link>
      <pubDate>Sat, 06 Jul 2019 21:57:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-clang-compilation-error-expected-unqualified-id/</guid>
      <description>&lt;p&gt;keywords: Clang Compilation Error&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]View Content of Static Library(.lib) and Shared Library(.dll)</title>
      <link>https://dawnarc.com/2019/07/c-view-content-of-static-library.lib-and-shared-library.dll/</link>
      <pubDate>Thu, 04 Jul 2019 21:27:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-view-content-of-static-library.lib-and-shared-library.dll/</guid>
      <description>&lt;p&gt;keywords: Library Viewer&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]error - templates must have C&#43;&#43; linkage</title>
      <link>https://dawnarc.com/2019/07/c-error-templates-must-have-c-linkage/</link>
      <pubDate>Tue, 02 Jul 2019 15:37:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-error-templates-must-have-c-linkage/</guid>
      <description>&lt;p&gt;keywords: C++ linkage&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Book Guide and List</title>
      <link>https://dawnarc.com/2019/05/c-book-guide-and-list/</link>
      <pubDate>Sun, 05 May 2019 20:52:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-book-guide-and-list/</guid>
      <description>&lt;p&gt;keywords: C++ Book&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Equivalent of instanceof (object type checking at run-time)- dynamic_cast</title>
      <link>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time-dynamic_cast/</link>
      <pubDate>Sun, 05 May 2019 11:33:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time-dynamic_cast/</guid>
      <description>&lt;p&gt;keywords: C++, instanceof, typeof&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]One std vector containing template class of multiple types</title>
      <link>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</link>
      <pubDate>Mon, 15 Apr 2019 17:28:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</guid>
      <description>&lt;p&gt;keywords: vector, list, element, multiple template types&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]STD Move &amp; Forward Notes</title>
      <link>https://dawnarc.com/2019/02/c-std-move-forward-notes/</link>
      <pubDate>Fri, 01 Feb 2019 14:05:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/02/c-std-move-forward-notes/</guid>
      <description>&lt;p&gt;keywords: VS2019, Code Analysis, Code Checking, std::move&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Address source line from crash callstack using binary</title>
      <link>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</link>
      <pubDate>Wed, 02 Jan 2019 11:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</guid>
      <description>&lt;p&gt;keywords: Windows Debugging Tools, Whitout PDB file, Crash, Dump file&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]const_cast</title>
      <link>https://dawnarc.com/2018/11/c-const_cast/</link>
      <pubDate>Fri, 30 Nov 2018 14:34:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/11/c-const_cast/</guid>
      <description>&lt;p&gt;You are not allowed to &lt;code&gt;const_cast&lt;/code&gt; variables that are actually &lt;code&gt;const&lt;/code&gt;. This results in undefined behavior.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39;</title>
      <link>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</link>
      <pubDate>Sun, 16 Sep 2018 20:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</guid>
      <description>Compiling Error:
error C2664: &#39;void TestFun01(std::string &amp;)&#39;: cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39; Solution:
add const to std::string&amp;amp; which is a parameter of function, like this:
void TestFun01(const std::string&amp;amp; text){std::cout &amp;lt;&amp;lt; text;}void TestFun02(){TestFun01(&amp;quot;abcd&amp;quot;);} this would produce compilation error:
void TestFun01(std::string&amp;amp; text){std::cout &amp;lt;&amp;lt; text;}void TestFun02(){TestFun01(&amp;quot;abcd&amp;quot;);}  人，越有智慧越显得孤独苦恼。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]shared_ptr 与 weak_ptr 区别</title>
      <link>https://dawnarc.com/2018/07/c-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 06 Jul 2018 14:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/c-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;与&lt;code&gt;weak_ptr&lt;/code&gt;有C++11引入。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]non-static member function as callback function and achieve inheritance</title>
      <link>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</link>
      <pubDate>Sat, 30 Jun 2018 17:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</guid>
      <description>keywords：C++ 非静态成员函数作为回调函数并实现继承多态
Base.hpp
#pragma onceclass Base{public:virtual void TestFun1(int Param) {}virtual void TestFun2(int Param) {}}; Child.hpp
#pragma once#include &amp;lt;iostream&amp;gt;#include &amp;quot;Base.hpp&amp;quot;class Child : public Base{public:void TestFun1(int Param) override{printf(&amp;quot;Fun1 : %d\n&amp;quot;, Param);}void TestFun2(int Param) override{printf(&amp;quot;Fun2 : %d\n&amp;quot;, Param);}}; EventManager.h
// Fill out your copyright notice in the Description page of Project Settings.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to erase an element from std vector by index</title>
      <link>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</link>
      <pubDate>Fri, 29 Jun 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</guid>
      <description>keywords：C++ 用索引删除 std::vector 中的数组元素
To delete a single element, you could do:
std::vector&amp;lt;int&amp;gt; vec;vec.push_back(6);vec.push_back(-17);vec.push_back(12);// Deletes the second element (vec[1])vec.erase(vec.begin() + 1); Or, to delete more than one element at once:
// Deletes the second through third elements (vec[1], vec[2])vec.erase(vec.begin() + 1, vec.begin() + 3); 参考自：How do I erase an element from std::vector&amp;lt;&amp;gt; by index?
https://stackoverflow.com/questions/875103/how-do-i-erase-an-element-from-stdvector-by-index
 无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归宿。---路遥《平凡的世界》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to add constructors or destructors to an unnamed class(为匿名类添加构造函数与析构函数)</title>
      <link>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 06 Jun 2018 17:44:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：匿名类，匿名结构体、构造函数、析构函数、Lambda
为匿名类添加构造函数与析构函数，有两种方式：
 C++98中在匿名类内部加一个命名类 C++11 Lambda语法  C++98 C++98中，可以在匿名类内部放一个命名类(named class )，然后再为命名类添加构造和析构函数，当匿名类构造或析构时，就会去调用命名类的构造函数和析构函数。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;int main() {struct {struct S {double a;int b;S() : a(sqrt(4)), b(42) { std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; }~S() { std::cout &amp;lt;&amp;lt; &amp;quot;destructed&amp;quot; &amp;lt;&amp;lt; std::endl; }} s;} instance1, instance2;std::cout &amp;lt;&amp;lt; &amp;quot;body&amp;quot; &amp;lt;&amp;lt; std::endl;} C++11 Lambda #include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;int main() {struct {double a { sqrt(4) };int b { []{std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl;return 42; }()};} instance1, instance2;} 参考 How to add constructors/destructors to an unnamed class?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to use erase of std map correctly</title>
      <link>https://dawnarc.com/2018/05/c-how-to-use-erase-of-std-map-correctly/</link>
      <pubDate>Fri, 11 May 2018 01:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/05/c-how-to-use-erase-of-std-map-correctly/</guid>
      <description>Origin Text: http://www.cnblogs.com/graphics/archive/2010/07/05/1771110.html
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;using namespace std ;int main(void) { map&amp;lt;int, string&amp;gt; m ;m.insert(pair&amp;lt;int, string&amp;gt;(1, &amp;quot;abc&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(2, &amp;quot;def&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(3, &amp;quot;def&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(4, &amp;quot;ghi&amp;quot;)) ;map&amp;lt;int, string&amp;gt;::iterator itor ;// Print mmap&amp;lt;int, string&amp;gt;::const_iterator citor ;for (citor = m.begin(); citor != m.end(); ++citor){cout &amp;lt;&amp;lt; citor-&amp;gt;first &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; citor-&amp;gt;second &amp;lt;&amp;lt; endl ;}return 0 ; }  Wrong way 1st: for (itor = m.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]读写二进制文件和文本文件</title>
      <link>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 20 Apr 2018 17:45:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</guid>
      <description>ifstream,ofstream读写二进制文件 #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(int argc, char** argv) { int a[5] = {1,2,3,4,5}; int b[5]; ofstream ouF; ouF.open(&amp;quot;./me.dat&amp;quot;, std::ofstream::binary); ouF.write(reinterpret_cast&amp;lt;const char*&amp;gt;(a), sizeof(int)*5); ouF.close(); ifstream inF; inF.open(&amp;quot;./me.dat&amp;quot;, std::ifstream::binary); inF.read(reinterpret_cast&amp;lt;char*&amp;gt;(b), sizeof(int)*5); inF.close(); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; endl; } return 0; }  参考自：https://blog.csdn.net/bendanban/article/details/30039193
C模式读写二进制文件 //采用C模式写二进制文件 void DataWrite_CMode() { //准备数据 double pos[200]; for(int i = 0; i &amp;lt; 200; i ++ ) pos[i] = i ; //写出数据 FILE *fid; fid = fopen(&amp;quot;binary.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]两个连续感叹号(双感叹号)的意义</title>
      <link>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</link>
      <pubDate>Sat, 03 Feb 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
      <description>网上看到有些代码在判断指针是否为空时，写两个感叹号：
void Test(A* Ptr){bool b = !!Ptr;...} 乍一看还以为是不可言传的高深操作，其实这是从JavaScript，TypeScript转C++的程序员，在用JS的语法写C++代码，JS必须这样，但是C++就不必了。
Defining double exclamation?
https://stackoverflow.com/questions/11374810/defining-double-exclamation
 时间是一只藏在黑暗中的温柔的手，在你一出神一恍惚之间，物走星移。----龙应台《目送》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 template alias和using(模板的模板)</title>
      <link>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 29 Sep 2017 18:47:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</guid>
      <description>keywords：alias template、模板别名、模板的模板
如果模版的type(T)不是具体类型，也是一个模板，C++11之前的语法不支持，现在C++11提供了新的语法支持这种场景：using identifier attr(optional) = type-id
示例：
template &amp;lt;template &amp;lt;typename&amp;gt; class&amp;gt;struct X{X(){std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot;;}};template &amp;lt;typename&amp;gt;struct Y{};template &amp;lt;typename T&amp;gt;using Z = Y&amp;lt;T&amp;gt;;template &amp;lt;&amp;gt;struct X&amp;lt;Y&amp;gt;{X(){std::cout &amp;lt;&amp;lt; &amp;quot;2&amp;quot;;}};int main(int argc, char* argv[]){X&amp;lt;Y&amp;gt; x1;X&amp;lt;Z&amp;gt; x2;} 运行结果：
21 Type alias, alias template (since C++11)
http://en.cppreference.com/w/cpp/language/type_alias
 尺之木必有节目，寸之玉必有瑕瓋。---《吕氏春秋》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]基础备忘：显式调用构造</title>
      <link>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 24 Aug 2017 16:51:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</guid>
      <description>最近两年一直在使用UE4 Stylized C++，标准C++的一些基础都快忘了。。。
示例代码：
#include &amp;lt;iostream&amp;gt;class CA{public://两种初始化成员变量的方法CA() : ia_(11){fa_ = 0.f;}CA(int val) : ia_(val){fa_ = 0.f;}//要想让子类能够访问，修饰符不可为privateprotected:int ia_;private:float fa_;};class CB : public CA{public://显示调用父类的有参构造函数CB() : CA(33), ib_(22){}int ib(){return ib_;}int ia(){return ia_;}private:int ib_;};int main(int argc, char* argv[]){CB b;std::cout &amp;lt;&amp;lt; b.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]可变参数_VA_ARGS__ </title>
      <link>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</link>
      <pubDate>Wed, 19 Apr 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</guid>
      <description>参考自：https://stackoverflow.com/questions/2124339/c-preprocessor-va-args-number-of-arguments
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdarg.h&amp;gt;#define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int))#define SUM(...) (sum(NUMARGS(__VA_ARGS__), __VA_ARGS__))void sum(int numargs, ...);int main(int argc, char *argv[]) {SUM(1);SUM(1, 2);SUM(1, 2, 3);SUM(1, 2, 3, 4);return 1;}void sum(int numargs, ...) {int total = 0;va_list ap;printf(&amp;quot;sum() called with %d params:&amp;quot;, numargs);va_start(ap, numargs);while (numargs--)total += va_arg(ap, int);va_end(ap);printf(&amp;quot; %d\n&amp;quot;, total);return;}  晚食以当肉，安步以当车，无罪以当贵，清静贞正以当虞。---《战国策》</description>
    </item>
    
    <item>
      <title>[C]printf函数源码实现</title>
      <link>https://dawnarc.com/2017/04/cprintf%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 17 Apr 2017 15:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/cprintf%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>printf函数源码实现
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; //va_start(arg,format),初始化参数指针arg，将函数参数format右边第一个参数地址赋值给arg //format必须是一个参数的指针，所以，此种类型函数至少要有一个普通的参数, //从而提供给va_start ,这样va_start才能找到可变参数在栈上的位置。 //va_arg(arg,char),获得arg指向参数的值，同时使arg指向下一个参数,char用来指名当前参数型 //va_end 在有些实现中可能会把arg改成无效值，这里，是把arg指针指向了 NULL,避免出现野指针 void print(const char *format, ...) { va_list arg; va_start(arg, format); while (*format) { char ret = *format; if (ret == &#39;%&#39;) { switch (*++format) { case &#39;c&#39;: { char ch = va_arg(arg, char); putchar(ch); break; } case &#39;s&#39;: { char *pc = va_arg(arg, char *); while (*pc) { putchar(*pc); pc++; } break; } default: break; } } else { putchar(*format); } format++; } va_end(arg); } int main() { print(&amp;quot;%s %s %c%c%c%c%c!</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]带参的回调函数编写技巧(模板函数)</title>
      <link>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Feb 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>比如要设置一连串的回调函数来响应键盘的0到9数字键，注册回调函数时无法把数字0到9作为函数参数一起注册，那么有没其他办法？答案肯定是有！具体方式如下：
1，先定义好需要回调的函数，假如：
void TestCallback(int index); 2，再定义一个模板函数将上面的函数封装：
template&amp;lt;int index&amp;gt;void TestCallback(){TestCallback(index);} 3，最后在注册回调时，将数字作为模板类型来注册：
CallbackMaster-&amp;gt;Bind(&amp;amp;MyClass::TestCallback&amp;lt;9&amp;gt;);  不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。——《荀子》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]for循环中的size参数优化问题</title>
      <link>https://dawnarc.com/2016/10/c-for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84size%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 11 Oct 2016 22:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/c-for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84size%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</guid>
      <description>之前网上一直有这么一条for循环优化建议： 将size提到第一个分号前，这样可以提高循环的效率，例如：
std::vector&amp;lt;int&amp;gt; aaa;for (size_t i = 0, size = aaa.size(); i &amp;lt; size; i++){printf(&amp;quot;bbb&amp;quot;);} 这个如果是很多年前，应该是有道理的，但是现在的编译器足够聪明，很多看起不够优化的代码，编译器会帮你处理。 以下是在VS2015下的汇编代码，结果是：size不前提反而可以节省两次mov指令。
size放在第一个分号后：
 for (size_t i = 0; i &amp;lt; aaa.size(); i++)00007FF7629E3147 mov qword ptr [rbp+48h],0 00007FF7629E314F jmp _20161011+3Ch (07FF7629E315Ch) 00007FF7629E3151 mov rax,qword ptr [rbp+48h] 00007FF7629E3155 inc rax 00007FF7629E3158 mov qword ptr [rbp+48h],rax 00007FF7629E315C lea rcx,[aaa] 00007FF7629E3160 call std::vector&amp;lt;int,std::allocator&amp;lt;int&amp;gt; &amp;gt;::size (07FF7629E16BDh) 00007FF7629E3165 cmp qword ptr [rbp+48h],rax 00007FF7629E3169 jae _20161011+59h (07FF7629E3179h)  size提到第一个分号前：</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]error C2034  type of bit field too small for number of bits</title>
      <link>https://dawnarc.com/2016/10/c-error-c2034-type-of-bit-field-too-small-for-number-of-bits/</link>
      <pubDate>Sun, 02 Oct 2016 13:40:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/c-error-c2034-type-of-bit-field-too-small-for-number-of-bits/</guid>
      <description>原文：http://ju.outofmemory.cn/entry/149128
struct A {int x:1;int y:2;int z:31;}; 此时是正确的
但是：
struct A {int x:1;int y:2;int z:33;}; 此时就会有编译错误：error C2034: &#39;z&#39; : type of bit field too small for number of bits
原文：http://zhidao.baidu.com/question/60696610.html
struct/class定义中在成员后面加冒号“：1”是什么意思？
这是位域操作的表示方法，也就是说后面加上“：1”的意思是这个成员的大小占所定义类型的1 bit，“：2”占2 bit，依次类推。当然大小不能超过所定义类型包含的总bit数。 一个bytes(字节)是8 bit(bit)。例如你的结构中定义的类型是u_char，一个字节，共8bit，最大就不能超过8。 32位机下， short是2字节，共16bit，最大就不能超过16. int是4字节，共32bit，最大就不能超过32. 依次类推。
这样定义比较省空间。例如你上面的结构，定义的变量类型是u_char，是一字节类型，即8bit。 fc_subtype占了4bit，fc_type占2bit,fc_protocol_version占2bit，共8bit，正好是一个字节。 其他八个成员,各占1bit，共8bit，正好也是一个字节。 因此你的结构的大小如果用sizeof（struct frame_control）计算，就是2bytes.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]protobuf中对中文编码与解析</title>
      <link>https://dawnarc.com/2016/09/c-protobuf%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 11 Sep 2016 02:43:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/09/c-protobuf%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90/</guid>
      <description>代码：
std::string str(&amp;quot;笑傲江湖DA&amp;quot;);int Len = str.size();char* data = new char[Len]();strcpy(data, str.data());HProtocol::test t1;t1.set_input_str(data);char* buff[1024];t1.SerializeToArray(buff, 1024);HProtocol::test t2;t2.ParseFromArray(buff, t1.ByteSize());//最终str3的值依然是str的值const char* str3 = t2.input_str().data(); </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]指针数组以及数组初始化</title>
      <link>https://dawnarc.com/2016/09/c-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 10 Sep 2016 16:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/09/c-%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>关键字：C++数组初始化
原文： http://www.cnblogs.com/mywebname/articles/2291540.html
定义：
int *pia = new int[10]; // array of 10 uninitialized ints 此 new 表达式分配了一个含有 10 个 int 型元素的数组，并返回指向该数组第一个元素的指针，此返回值初始化了指针 pia。 在自由存储区中创建的数组对象是没有名字的，只能通过其地址间接地访问堆中的对象。 注意：C++使用new和delete在堆（自由存储区）上分配和释放动态数组。
动态数组初始化： 1.元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。 2.对于内置数据类型元素的数组，必须使用()来显示指定程序执行初始化操作，否则程序不执行初始化操作：
int *pia = new int[10]; // 每个元素都没有初始化int *pia2 = new int[10] (); // 每个元素初始化为0 3.类类型元素的数组，则无论是否使用（），都会自动调用其默认构造函数来初始化：
string *psa = new string[10]; // 每个元素调用默认构造函数初始化string *psa = new string[10](); // 每个元素调用默认构造函数初始化 动态分配空数组： char *cp = new char[0]; 之后，可以动态改变cp的维数。
动态释放： delete [] pia; 典型使用示例： const char *pc = &amp;quot;a very long literal string&amp;quot;; // 处理C风格字符串时使用const指针const size_t len = strlen(pc) +1; // size_t用于数组的大小和下标for (size_t ix = 0; ix !</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]如何将std vector反序</title>
      <link>https://dawnarc.com/2016/08/c-%E5%A6%82%E4%BD%95%E5%B0%86std-vector%E5%8F%8D%E5%BA%8F/</link>
      <pubDate>Wed, 17 Aug 2016 15:59:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/08/c-%E5%A6%82%E4%BD%95%E5%B0%86std-vector%E5%8F%8D%E5%BA%8F/</guid>
      <description>使用std::reverse函数：
#include &amp;lt;vector&amp;gt;#include &amp;lt;iostream&amp;gt;#include &amp;lt;iterator&amp;gt;#include &amp;lt;algorithm&amp;gt;int main(){std::vector&amp;lt;int&amp;gt; v({1,2,3});std::reverse(std::begin(v), std::end(v));std::cout &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; v[2] &amp;lt;&amp;lt; &#39;\n&#39;;int a[] = {4, 5, 6, 7};std::reverse(std::begin(a), std::end(a));std::cout &amp;lt;&amp;lt; a[0] &amp;lt;&amp;lt; a[1] &amp;lt;&amp;lt; a[2] &amp;lt;&amp;lt; a[3] &amp;lt;&amp;lt; &#39;\n&#39;;} </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]vector等容器的元素引用问题</title>
      <link>https://dawnarc.com/2016/08/c-vector%E7%AD%89%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 10 Aug 2016 13:57:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/08/c-vector%E7%AD%89%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <description>示例代码：
struct TestStru{int val;TestStru(){val = -1;}};std::vector&amp;lt;TestStru&amp;gt; TestArr;TestStru e1;TestArr.push_back(e1);TestStru&amp;amp; e = TestArr[0];e.val = 999;TestStru e2;TestArr.push_back(e2); 变量e为数组TestArr内元素的引用，但是当执行TestArr.push_back(e2);时，e就失效了。原因是push_back的时候内部容器有扩容，另外vector的默认容量为0。</description>
    </item>
    
    <item>
      <title>MSVC自带的内存泄漏检测工具</title>
      <link>https://dawnarc.com/2016/06/msvc%E8%87%AA%E5%B8%A6%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 05 Jun 2016 21:42:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/msvc%E8%87%AA%E5%B8%A6%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</guid>
      <description>Finding Memory Leaks Using the CRT Library
https://msdn.microsoft.com/en-us/library/x98tx3cf.aspx</description>
    </item>
    
    <item>
      <title>C风格new操作符malloc，如何调用构造函数</title>
      <link>https://dawnarc.com/2016/06/c%E9%A3%8E%E6%A0%BCnew%E6%93%8D%E4%BD%9C%E7%AC%A6malloc%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 04 Jun 2016 17:40:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/c%E9%A3%8E%E6%A0%BCnew%E6%93%8D%E4%BD%9C%E7%AC%A6malloc%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：C++, new, placement new
原文： http://stackoverflow.com/questions/4956249/using-malloc-instead-of-new-and-calling-the-copy-constructor-when-the-object-is
You&amp;rsquo;ll need to use placement new after getting the raw memory from malloc.
void* mem = malloc(sizeof(S));S* s = new (mem) S(); //this is the so called &amp;quot;placement new&amp;quot; When you&amp;rsquo;re done with the object you have to make sure to explicitly call its destructor.
s-&amp;gt;~S();free(mem); </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Memory Address Issues and Memory Leak Detecter</title>
      <link>https://dawnarc.com/2016/05/c-memory-address-issues-and-memory-leak-detecter/</link>
      <pubDate>Sat, 28 May 2016 21:42:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/05/c-memory-address-issues-and-memory-leak-detecter/</guid>
      <description>Memory Issues Detecter AddressSanitizer, ThreadSanitizer, MemorySanitizer
https://github.com/google/sanitizers
Visual Leak Detector for Visual C++ 2008-2015
https://github.com/KindDragon/vld
Crash Reporting Mirror of Google Breakpad project
https://github.com/google/breakpad
Advanced, cross-platform crash management solution for C/C++ applications running in every environment.
https://backtrace.io/</description>
    </item>
    
  </channel>
</rss>