<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 玄冬Wong</title>
    <link>https://dawnarc.com/categories/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 06 Jul 2018 14:19:40 +0800</lastBuildDate>
    
	<atom:link href="https://dawnarc.com/categories/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 shared_ptr 与 weak_ptr 区别</title>
      <link>https://dawnarc.com/2018/07/c--c--11-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 06 Jul 2018 14:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/c--c--11-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</guid>
      <description>shared_ptr 语法：
#include &amp;lt;memory&amp;gt; shared_ptr&amp;lt;A&amp;gt; x(new A);  shared_ptr 相当于 对象引用计数器。每当对 shared_ptr 赋值操作一次，则其引用对象的计数+1。当某对象的引用计数为0时，则该对象自动销毁。
weak_ptr 语法：
#include &amp;lt;memory&amp;gt; weak_ptr&amp;lt;A&amp;gt; x(new A);  weak_ptr 典型应用是缓存：例如我们在缓存中存放了一个 raw pointer 来指向某个对象，如果这个对象在其他地方被销毁了，那么缓存中的这个 raw pointer 指向的对象不存在。如果我们希望某个对象在其他地方被销毁时，缓存中指向该对象的指针也马上被置为 null，那么就可以使用 weak_ptr。
参考自：
shared_ptr and weak_ptr differences
https://stackoverflow.com/questions/4984381/shared-ptr-and-weak-ptr-differences
When is std::weak_ptr useful?
https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]non-static member function as callback function and achieve inheritance</title>
      <link>https://dawnarc.com/2018/06/c--non-static-member-function-as-callback-function-and-achieve-inheritance/</link>
      <pubDate>Sat, 30 Jun 2018 17:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c--non-static-member-function-as-callback-function-and-achieve-inheritance/</guid>
      <description>keywords：C++ 非静态成员函数作为回调函数并实现继承多态
Base.hpp
#pragma once class Base { public: virtual void TestFun1(int Param) {} virtual void TestFun2(int Param) {} };  Child.hpp
#pragma once #include &amp;lt;iostream&amp;gt; #include &amp;quot;Base.hpp&amp;quot; class Child : public Base { public: void TestFun1(int Param) override { printf(&amp;quot;Fun1 : %d\n&amp;quot;, Param); } void TestFun2(int Param) override { printf(&amp;quot;Fun2 : %d\n&amp;quot;, Param); } };  EventManager.h
// Fill out your copyright notice in the Description page of Project Settings.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to erase an element from std vector by index</title>
      <link>https://dawnarc.com/2018/06/c--how-to-erase-an-element-from-std-vector-by-index/</link>
      <pubDate>Fri, 29 Jun 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c--how-to-erase-an-element-from-std-vector-by-index/</guid>
      <description>keywords：C++ 用索引删除 std::vector 中的数组元素
To delete a single element, you could do:
std::vector&amp;lt;int&amp;gt; vec; vec.push_back(6); vec.push_back(-17); vec.push_back(12); // Deletes the second element (vec[1]) vec.erase(vec.begin() + 1);  Or, to delete more than one element at once:
// Deletes the second through third elements (vec[1], vec[2]) vec.erase(vec.begin() + 1, vec.begin() + 3);  参考自：How do I erase an element from std::vector&amp;lt;&amp;gt; by index?
https://stackoverflow.com/questions/875103/how-do-i-erase-an-element-from-stdvector-by-index
无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归宿。---路遥《平凡的世界》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to add constructors or destructors to an unnamed class(为匿名类添加构造函数与析构函数)</title>
      <link>https://dawnarc.com/2018/06/c--how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 06 Jun 2018 17:44:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c--how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：匿名类，匿名结构体、构造函数、析构函数、Lambda
为匿名类添加构造函数与析构函数，有两种方式：
 C++98中在匿名类内部加一个命名类 C++11 Lambda语法  C++98 C++98中，可以在匿名类内部放一个命名类(named class )，然后再为命名类添加构造和析构函数，当匿名类构造或析构时，就会去调用命名类的构造函数和析构函数。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; int main() { struct { struct S { double a; int b; S() : a(sqrt(4)), b(42) { std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; } ~S() { std::cout &amp;lt;&amp;lt; &amp;quot;destructed&amp;quot; &amp;lt;&amp;lt; std::endl; } } s; } instance1, instance2; std::cout &amp;lt;&amp;lt; &amp;quot;body&amp;quot; &amp;lt;&amp;lt; std::endl; }  C++11 Lambda #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; int main() { struct { double a { sqrt(4) }; int b { []{ std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; return 42; }() }; } instance1, instance2; }  参考 How to add constructors/destructors to an unnamed class?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]正确使用STL-MAP中Erase函数</title>
      <link>https://dawnarc.com/2018/05/c--%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8stl-map%E4%B8%ADerase%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 11 May 2018 01:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/05/c--%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8stl-map%E4%B8%ADerase%E5%87%BD%E6%95%B0/</guid>
      <description>原文：http://www.cnblogs.com/graphics/archive/2010/07/05/1771110.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; using namespace std ; int main(void) { map&amp;lt;int, string&amp;gt; m ; m.insert(pair&amp;lt;int, string&amp;gt;(1, &amp;quot;abc&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(2, &amp;quot;def&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(3, &amp;quot;def&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(4, &amp;quot;ghi&amp;quot;)) ; map&amp;lt;int, string&amp;gt;::iterator itor ; // 错误的写法 for (itor = m.begin(); itor != m.end(); ++itor) { if (itor-&amp;gt;second == &amp;quot;def&amp;quot;) { m.erase(itor) ; // map是关联式容器，调用erase后，当前迭代器已经失效 } } // 正确的写法 for (itor = m.begin(); itor != m.end();) { if (itor-&amp;gt;second == &amp;quot;def&amp;quot;) { m.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]读写二进制文件和文本文件</title>
      <link>https://dawnarc.com/2018/04/c--%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 20 Apr 2018 17:45:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/c--%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</guid>
      <description>ifstream,ofstream读写二进制文件 #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(int argc, char** argv) { int a[5] = {1,2,3,4,5}; int b[5]; ofstream ouF; ouF.open(&amp;quot;./me.dat&amp;quot;, std::ofstream::binary); ouF.write(reinterpret_cast&amp;lt;const char*&amp;gt;(a), sizeof(int)*5); ouF.close(); ifstream inF; inF.open(&amp;quot;./me.dat&amp;quot;, std::ifstream::binary); inF.read(reinterpret_cast&amp;lt;char*&amp;gt;(b), sizeof(int)*5); inF.close(); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; endl; } return 0; }  参考自：https://blog.csdn.net/bendanban/article/details/30039193
C模式读写二进制文件 //采用C模式写二进制文件 void DataWrite_CMode() { //准备数据 double pos[200]; for(int i = 0; i &amp;lt; 200; i ++ ) pos[i] = i ; //写出数据 FILE *fid; fid = fopen(&amp;quot;binary.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]两个连续感叹号(双感叹号)的意义</title>
      <link>https://dawnarc.com/2018/02/c--%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</link>
      <pubDate>Sat, 03 Feb 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/02/c--%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
      <description>一种获取bool值的技巧，在获取bool值的同时有保证代码有可读性。
比如这种写法，直接将一个指针赋给一个bool值，看上去有点怪，不利于阅读。
void Test(A* Ptr) { bool b = Ptr; ... }  但是加两个感叹号，就可以清楚表明我是要明确获得一个bool。
void Test(A* Ptr) { bool b = !!Ptr; ... }  当然用三元运算符? : 也可以，不过要多敲一些字符。
void Test(A* Ptr) { bool b = Ptr ? true : false; ... }  三种方式的CPU指令数是完全一样，开销相同。
 bool b = !!Ptr; 003EA318 cmp dword ptr [Ptr],0 003EA31C je Test+6Ah (03EA32Ah) 003EA31E mov dword ptr [ebp-0E8h],1 003EA328 jmp Test+74h (03EA334h) 003EA32A mov dword ptr [ebp-0E8h],0 003EA334 mov al,byte ptr [ebp-0E8h] 003EA33A mov byte ptr [b],al  时间是一只藏在黑暗中的温柔的手，在你一出神一恍惚之间，物走星移。----龙应台《目送》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 template alias和using(模板的模板)</title>
      <link>https://dawnarc.com/2017/09/c--c--11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 29 Sep 2017 18:47:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/09/c--c--11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</guid>
      <description>keywords：alias template、模板别名、模板的模板
如果模版的type(T)不是具体类型，也是一个模板，C++11之前的语法不支持，现在C++11提供了新的语法支持这种场景：using identifier attr(optional) = type-id
示例：
template &amp;lt;template &amp;lt;typename&amp;gt; class&amp;gt; struct X { X() { std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot;; } }; template &amp;lt;typename&amp;gt; struct Y { }; template &amp;lt;typename T&amp;gt; using Z = Y&amp;lt;T&amp;gt;; template &amp;lt;&amp;gt; struct X&amp;lt;Y&amp;gt; { X() { std::cout &amp;lt;&amp;lt; &amp;quot;2&amp;quot;; } }; int main(int argc, char* argv[]) { X&amp;lt;Y&amp;gt; x1; X&amp;lt;Z&amp;gt; x2; }  运行结果：
21  Type alias, alias template (since C++11)
http://en.cppreference.com/w/cpp/language/type_alias
尺之木必有节目，寸之玉必有瑕瓋。---《吕氏春秋》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]基础备忘：显式调用构造</title>
      <link>https://dawnarc.com/2017/08/c--%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 24 Aug 2017 16:51:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/08/c--%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</guid>
      <description>最近两年一直是在UE4的编译器下使用C++，标准C++的一些基础都快忘了。。。
示例代码：
#include &amp;lt;iostream&amp;gt; class CA { public: //两种初始化成员变量的方法 CA() : ia_(11) { fa_ = 0.f; } CA(int val) : ia_(val) { fa_ = 0.f; } //要想让子类能够访问，修饰符不可为private protected: int ia_; private: float fa_; }; class CB : public CA { public: //显示调用父类的有参构造函数 CB() : CA(33), ib_(22) { } int ib() { return ib_; } int ia() { return ia_; } private: int ib_; }; int main(int argc, char* argv[]) { CB b; std::cout &amp;lt;&amp;lt; b.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]可变参数_VA_ARGS__ </title>
      <link>https://dawnarc.com/2017/04/c--%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</link>
      <pubDate>Wed, 19 Apr 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/c--%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</guid>
      <description>参考自：https://stackoverflow.com/questions/2124339/c-preprocessor-va-args-number-of-arguments
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; #define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int)) #define SUM(...) (sum(NUMARGS(__VA_ARGS__), __VA_ARGS__)) void sum(int numargs, ...); int main(int argc, char *argv[]) { SUM(1); SUM(1, 2); SUM(1, 2, 3); SUM(1, 2, 3, 4); return 1; } void sum(int numargs, ...) { int total = 0; va_list ap; printf(&amp;quot;sum() called with %d params:&amp;quot;, numargs); va_start(ap, numargs); while (numargs--) total += va_arg(ap, int); va_end(ap); printf(&amp;quot; %d\n&amp;quot;, total); return; }  晚食以当肉，安步以当车，无罪以当贵，清静贞正以当虞。---《战国策》</description>
    </item>
    
    <item>
      <title>[C]printf函数源码实现</title>
      <link>https://dawnarc.com/2017/04/cprintf%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</link>
      <pubDate>Mon, 17 Apr 2017 15:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/cprintf%E5%87%BD%E6%95%B0%E6%BA%90%E7%A0%81%E5%AE%9E%E7%8E%B0/</guid>
      <description>printf函数源码实现
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; //va_start(arg,format),初始化参数指针arg，将函数参数format右边第一个参数地址赋值给arg //format必须是一个参数的指针，所以，此种类型函数至少要有一个普通的参数, //从而提供给va_start ,这样va_start才能找到可变参数在栈上的位置。 //va_arg(arg,char),获得arg指向参数的值，同时使arg指向下一个参数,char用来指名当前参数型 //va_end 在有些实现中可能会把arg改成无效值，这里，是把arg指针指向了 NULL,避免出现野指针 void print(const char *format, ...) { va_list arg; va_start(arg, format); while (*format) { char ret = *format; if (ret == &#39;%&#39;) { switch (*++format) { case &#39;c&#39;: { char ch = va_arg(arg, char); putchar(ch); break; } case &#39;s&#39;: { char *pc = va_arg(arg, char *); while (*pc) { putchar(*pc); pc++; } break; } default: break; } } else { putchar(*format); } format++; } va_end(arg); } int main() { print(&amp;quot;%s %s %c%c%c%c%c!</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]带参的回调函数编写技巧(模板函数)</title>
      <link>https://dawnarc.com/2017/02/c--%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Feb 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/c--%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>比如要设置一连串的回调函数来响应键盘的0到9数字键，注册回调函数时无法把数字0到9作为函数参数一起注册，那么有没其他办法？答案肯定是有！具体方式如下：
1，先定义好需要回调的函数，假如：
void TestCallback(int index);  2，再定义一个模板函数将上面的函数封装：
template&amp;lt;int index&amp;gt; void TestCallback() { TestCallback(index); }  3，最后在注册回调时，将数字作为模板类型来注册：
CallbackMaster-&amp;gt;Bind(&amp;amp;MyClass::TestCallback&amp;lt;9&amp;gt;);  不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。——《荀子》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]for循环中的size参数优化问题</title>
      <link>https://dawnarc.com/2016/10/c--for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84size%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 11 Oct 2016 22:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/c--for%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84size%E5%8F%82%E6%95%B0%E4%BC%98%E5%8C%96%E9%97%AE%E9%A2%98/</guid>
      <description>之前网上一直有这么一条for循环优化建议： 将size提到第一个分号前，这样可以提高循环的效率，例如：
std::vector&amp;lt;int&amp;gt; aaa; for (size_t i = 0, size = aaa.size(); i &amp;lt; size; i++) { printf(&amp;quot;bbb&amp;quot;); }  这个如果是很多年前，应该是有道理的，但是现在的编译器足够聪明，很多看起不够优化的代码，编译器会帮你处理。 以下是在VS2015下的汇编代码，结果是：size不前提反而可以节省两次mov指令。
size放在第一个分号后：
 for (size_t i = 0; i &amp;lt; aaa.size(); i++) 00007FF7629E3147 mov qword ptr [rbp+48h],0 00007FF7629E314F jmp _20161011+3Ch (07FF7629E315Ch) 00007FF7629E3151 mov rax,qword ptr [rbp+48h] 00007FF7629E3155 inc rax 00007FF7629E3158 mov qword ptr [rbp+48h],rax 00007FF7629E315C lea rcx,[aaa] 00007FF7629E3160 call std::vector&amp;lt;int,std::allocator&amp;lt;int&amp;gt; &amp;gt;::size (07FF7629E16BDh) 00007FF7629E3165 cmp qword ptr [rbp+48h],rax 00007FF7629E3169 jae _20161011+59h (07FF7629E3179h)  size提到第一个分号前：</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]error C2034  type of bit field too small for number of bits</title>
      <link>https://dawnarc.com/2016/10/c--error-c2034--type-of-bit-field-too-small-for-number-of-bits/</link>
      <pubDate>Sun, 02 Oct 2016 13:40:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/c--error-c2034--type-of-bit-field-too-small-for-number-of-bits/</guid>
      <description>原文：http://ju.outofmemory.cn/entry/149128
struct A { int x:1; int y:2; int z:31; };  此时是正确的
但是：
struct A { int x:1; int y:2; int z:33; };  此时就会有编译错误：error C2034: &#39;z&#39; : type of bit field too small for number of bits
原文：http://zhidao.baidu.com/question/60696610.html
struct/class定义中在成员后面加冒号“：1”是什么意思？
这是位域操作的表示方法，也就是说后面加上“：1”的意思是这个成员的大小占所定义类型的1 bit，“：2”占2 bit，依次类推。当然大小不能超过所定义类型包含的总bit数。 一个bytes(字节)是8 bit(bit)。例如你的结构中定义的类型是u_char，一个字节，共8bit，最大就不能超过8。 32位机下， short是2字节，共16bit，最大就不能超过16. int是4字节，共32bit，最大就不能超过32. 依次类推。
这样定义比较省空间。例如你上面的结构，定义的变量类型是u_char，是一字节类型，即8bit。 fc_subtype占了4bit，fc_type占2bit,fc_protocol_version占2bit，共8bit，正好是一个字节。 其他八个成员,各占1bit，共8bit，正好也是一个字节。 因此你的结构的大小如果用sizeof（struct frame_control）计算，就是2bytes.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]protobuf中对中文编码与解析</title>
      <link>https://dawnarc.com/2016/09/c--protobuf%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90/</link>
      <pubDate>Sun, 11 Sep 2016 02:43:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/09/c--protobuf%E4%B8%AD%E5%AF%B9%E4%B8%AD%E6%96%87%E7%BC%96%E7%A0%81%E4%B8%8E%E8%A7%A3%E6%9E%90/</guid>
      <description>代码：
std::string str(&amp;quot;笑傲江湖DA&amp;quot;); int Len = str.size(); char* data = new char[Len](); strcpy(data, str.data()); HProtocol::test t1; t1.set_input_str(data); char* buff[1024]; t1.SerializeToArray(buff, 1024); HProtocol::test t2; t2.ParseFromArray(buff, t1.ByteSize()); //最终str3的值依然是str的值 const char* str3 = t2.input_str().data();  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]指针数组以及数组初始化</title>
      <link>https://dawnarc.com/2016/09/c--%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</link>
      <pubDate>Sat, 10 Sep 2016 16:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/09/c--%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%BB%A5%E5%8F%8A%E6%95%B0%E7%BB%84%E5%88%9D%E5%A7%8B%E5%8C%96/</guid>
      <description>关键字：C++数组初始化
原文： http://www.cnblogs.com/mywebname/articles/2291540.html
定义：
int *pia = new int[10]; // array of 10 uninitialized ints  此 new 表达式分配了一个含有 10 个 int 型元素的数组，并返回指向该数组第一个元素的指针，此返回值初始化了指针 pia。 在自由存储区中创建的数组对象是没有名字的，只能通过其地址间接地访问堆中的对象。 注意：C++使用new和delete在堆（自由存储区）上分配和释放动态数组。
动态数组初始化： 1.元素只能初始化为元素类型的默认值，而不能像数组变量一样，用初始化列表为数组元素提供各不相同的初值。 2.对于内置数据类型元素的数组，必须使用()来显示指定程序执行初始化操作，否则程序不执行初始化操作：
int *pia = new int[10]; // 每个元素都没有初始化 int *pia2 = new int[10] (); // 每个元素初始化为0  3.类类型元素的数组，则无论是否使用（），都会自动调用其默认构造函数来初始化：
string *psa = new string[10]; // 每个元素调用默认构造函数初始化 string *psa = new string[10](); // 每个元素调用默认构造函数初始化  动态分配空数组： char *cp = new char[0];  之后，可以动态改变cp的维数。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]如何将std vector反序</title>
      <link>https://dawnarc.com/2016/08/c--%E5%A6%82%E4%BD%95%E5%B0%86std-vector%E5%8F%8D%E5%BA%8F/</link>
      <pubDate>Wed, 17 Aug 2016 15:59:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/08/c--%E5%A6%82%E4%BD%95%E5%B0%86std-vector%E5%8F%8D%E5%BA%8F/</guid>
      <description>使用std::reverse函数：
#include &amp;lt;vector&amp;gt; #include &amp;lt;iostream&amp;gt; #include &amp;lt;iterator&amp;gt; #include &amp;lt;algorithm&amp;gt; int main() { std::vector&amp;lt;int&amp;gt; v({1,2,3}); std::reverse(std::begin(v), std::end(v)); std::cout &amp;lt;&amp;lt; v[0] &amp;lt;&amp;lt; v[1] &amp;lt;&amp;lt; v[2] &amp;lt;&amp;lt; &#39;\n&#39;; int a[] = {4, 5, 6, 7}; std::reverse(std::begin(a), std::end(a)); std::cout &amp;lt;&amp;lt; a[0] &amp;lt;&amp;lt; a[1] &amp;lt;&amp;lt; a[2] &amp;lt;&amp;lt; a[3] &amp;lt;&amp;lt; &#39;\n&#39;; }  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]vector等容器的元素引用问题</title>
      <link>https://dawnarc.com/2016/08/c--vector%E7%AD%89%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 10 Aug 2016 13:57:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/08/c--vector%E7%AD%89%E5%AE%B9%E5%99%A8%E7%9A%84%E5%85%83%E7%B4%A0%E5%BC%95%E7%94%A8%E9%97%AE%E9%A2%98/</guid>
      <description>示例代码：
struct TestStru { int val; TestStru() { val = -1; } }; std::vector&amp;lt;TestStru&amp;gt; TestArr; TestStru e1; TestArr.push_back(e1); TestStru&amp;amp; e = TestArr[0]; e.val = 999; TestStru e2; TestArr.push_back(e2);  变量e为数组TestArr内元素的引用，但是当执行TestArr.push_back(e2);时，e就失效了。原因是push_back的时候内部容器有扩容，另外vector的默认容量为0。</description>
    </item>
    
    <item>
      <title>MSVC自带的内存泄漏检测工具</title>
      <link>https://dawnarc.com/2016/06/msvc%E8%87%AA%E5%B8%A6%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sun, 05 Jun 2016 21:42:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/msvc%E8%87%AA%E5%B8%A6%E7%9A%84%E5%86%85%E5%AD%98%E6%B3%84%E6%BC%8F%E6%A3%80%E6%B5%8B%E5%B7%A5%E5%85%B7/</guid>
      <description>Finding Memory Leaks Using the CRT Library https://msdn.microsoft.com/en-us/library/x98tx3cf.aspx</description>
    </item>
    
    <item>
      <title>C风格new操作符malloc，如何调用构造函数</title>
      <link>https://dawnarc.com/2016/06/c%E9%A3%8E%E6%A0%BCnew%E6%93%8D%E4%BD%9C%E7%AC%A6malloc%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</link>
      <pubDate>Sat, 04 Jun 2016 17:40:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/c%E9%A3%8E%E6%A0%BCnew%E6%93%8D%E4%BD%9C%E7%AC%A6malloc%E5%A6%82%E4%BD%95%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：C++, new, placement new
原文： http://stackoverflow.com/questions/4956249/using-malloc-instead-of-new-and-calling-the-copy-constructor-when-the-object-is
You&amp;rsquo;ll need to use placement new after getting the raw memory from malloc.
void* mem = malloc(sizeof(S)); S* s = new (mem) S(); //this is the so called &amp;quot;placement new&amp;quot;  When you&amp;rsquo;re done with the object you have to make sure to explicitly call its destructor.
s-&amp;gt;~S(); free(mem);  </description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]内存污染检测分析工具</title>
      <link>https://dawnarc.com/2016/05/c--%E5%86%85%E5%AD%98%E6%B1%A1%E6%9F%93%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</link>
      <pubDate>Sat, 28 May 2016 21:42:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/05/c--%E5%86%85%E5%AD%98%E6%B1%A1%E6%9F%93%E6%A3%80%E6%B5%8B%E5%88%86%E6%9E%90%E5%B7%A5%E5%85%B7/</guid>
      <description>不仅可以检测内存溢出，还能检测内存泄漏以及线程竞争，但是官方只支持Clang/LLVM https://github.com/google/sanitizers</description>
    </item>
    
  </channel>
</rss>