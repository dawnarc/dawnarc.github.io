<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Error on 玄冬Wong</title>
    <link>https://dawnarc.com/tags/error/</link>
    <description>Recent content in Error on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Mar 2017 23:14:40 +0800</lastBuildDate>
    
	<atom:link href="https://dawnarc.com/tags/error/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Windows]Epic Games Launcher Error Codes 2503, 2502</title>
      <link>https://dawnarc.com/2017/03/windowsepic-games-launcher-error-codes-2503-2502/</link>
      <pubDate>Wed, 08 Mar 2017 23:14:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/03/windowsepic-games-launcher-error-codes-2503-2502/</guid>
      <description>问题： 安装launcher时报错，error 2503 2502
解决办法： 管理员模式下的CMD中执行命令：
msiexec /package EpicGamesLauncherInstaller-2.12.24-3321064.msi  参考： https://answers.unrealengine.com/questions/368475/epic-games-launcher-error-codes-2503-2502.html
东风渐绿西湖岸，雁已还、人来南归。—周密《高阳台》</description>
    </item>
    
    <item>
      <title>[UE4][C&#43;&#43;]不调用父类BeginDestroy()会导致的崩溃问题</title>
      <link>https://dawnarc.com/2016/11/ue4c--%E4%B8%8D%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BBbegindestroy%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 01 Nov 2016 23:23:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/11/ue4c--%E4%B8%8D%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BBbegindestroy%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</guid>
      <description>出现以下异常的原因是：重写了BeginDestroy()函数但没有在其内部执行Super::BeginDestroy()。
Fatal error: [File:D:\Build\++UE4+Release-4.13+Compile\Sync\Engine\Source\Runtime\CoreUObject\Private\UObject\Obj.cpp] [Line: 742] HPlayerController None.None:None.HPlayerController_0 failed to route BeginDestroy UE4Editor_Core!FDebug::AssertFailed() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\private\misc\outputdevice.cpp:421] UE4Editor_CoreUObject!UObject::ConditionalBeginDestroy() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\obj.cpp:742] UE4Editor_CoreUObject!CollectGarbageInternal() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\garbagecollection.cpp:1281] UE4Editor_CoreUObject!CollectGarbage() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\garbagecollection.cpp:1320] UE4Editor_UnrealEd!UEditorEngine::EndPlayMap() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:408] UE4Editor_LevelEditor!FLevelViewportLayout::~FLevelViewportLayout() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\leveleditor\private\levelviewportlayout.cpp:145] UE4Editor_LevelEditor!FLevelViewportLayout2x2::`scalar deleting destructor&#39;() UE4Editor_LevelEditor!FLevelViewportTabContent::~FLevelViewportTabContent() UE4Editor_LevelEditor!SharedPointerInternals::TReferenceControllerWithDeleter&amp;lt;FLevelViewportTabContent,SharedPointerInternals::DefaultDeleter&amp;lt;FLevelViewportTabContent&amp;gt; &amp;gt;::DestroyObject() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\templates\sharedpointerinternals.h:104] UE4Editor_LevelEditor!SViewportsOverlay::~SViewportsOverlay() UE4Editor_LevelEditor!SViewportsOverlay::`scalar deleting destructor&#39;() UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot() UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget() UE4Editor_Slate!SBorder::`vector deleting destructor&#39;() UE4Editor_SlateCore!TIndirectArray&amp;lt;SOverlay::FOverlaySlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474] UE4Editor_SlateCore!SOverlay::~SOverlay() UE4Editor_Slate!SOverlay::`scalar deleting destructor&#39;() UE4Editor_SlateCore!TIndirectArray&amp;lt;SBoxPanel::FSlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474] UE4Editor_SlateCore!SBoxPanel::~SBoxPanel() UE4Editor_Slate!SVerticalBox::`scalar deleting destructor&#39;() UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot() UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget() UE4Editor_Slate!SDockingTabStack::`vector deleting destructor&#39;() UE4Editor_SlateCore!FSlotBase::~FSlotBase() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\slatecore\private\slotbase.cpp:34] UE4Editor_Slate!TIndirectArray&amp;lt;SSplitter::FSlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474] UE4Editor_Slate!SSplitter::~SSplitter() UE4Editor_Slate!SSplitter::`vector deleting destructor&#39;() UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot() UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget() UE4Editor_Slate!SDockingSplitter::`vector deleting destructor&#39;() UE4Editor_SlateCore!</description>
    </item>
    
    <item>
      <title>[UE4]AddToRoot()要与RemoveFromRoot成对出现</title>
      <link>https://dawnarc.com/2016/10/ue4addtoroot%E8%A6%81%E4%B8%8Eremovefromroot%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0/</link>
      <pubDate>Wed, 19 Oct 2016 15:33:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/ue4addtoroot%E8%A6%81%E4%B8%8Eremovefromroot%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0/</guid>
      <description>如果对某个UObject执行了AddToRoot()，那么需要在该UObject所属的上级UOject销毁前，执行RemoveFromRoot()，否则当程序退出时，会出现崩溃，崩溃堆栈：
Assertion failed: !IsRooted() [File:d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\public\uobject\UObjectBaseUtility.h] [Line: 135] UE4Editor_Core!FDebug::AssertFailed() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\private\misc\outputdevice.cpp:421] UE4Editor_UnrealEd!&amp;lt;lambda_26419e543909ee92ebfb672b1e9c08dc&amp;gt;::operator()() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:384] UE4Editor_CoreUObject!ForEachObjectWithOuter() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\uobjecthash.cpp:678] UE4Editor_UnrealEd!UEditorEngine::EndPlayMap() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:380] UE4Editor_UnrealEd!UEditorEngine::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\editorengine.cpp:1653] UE4Editor_UnrealEd!UUnrealEdEngine::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\unrealedengine.cpp:371] UE4Editor!FEngineLoop::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\launchengineloop.cpp:2834] UE4Editor!GuardedMain() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\launch.cpp:156] UE4Editor!GuardedMainWrapper() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\windows\launchwindows.cpp:126] UE4Editor!WinMain() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\windows\launchwindows.cpp:202] UE4Editor!__scrt_common_main_seh() [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl:264] kernel32 ntdll  </description>
    </item>
    
    <item>
      <title>[Android NDK]错误log：ExtMediaPlayer-JNI(22104) env-IsInstanceOf fails</title>
      <link>https://dawnarc.com/2016/10/android-ndk%E9%94%99%E8%AF%AFlogextmediaplayer-jni22104-env-isinstanceof-fails/</link>
      <pubDate>Mon, 17 Oct 2016 15:35:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndk%E9%94%99%E8%AF%AFlogextmediaplayer-jni22104-env-isinstanceof-fails/</guid>
      <description>如果你的android app出现以下两种错误log提示，并不影响你的app运行，如果你的app崩溃，可以忽略下面两种log。
10-17 16:59:29.263: E/ExtMediaPlayer-JNI(22104): env-&amp;gt;IsInstanceOf fails 10-17 16:59:29.263: E/MediaPlayer-JNI(22104): JNIMediaPlayerFactory: bIsQCMediaPlayerPresent 0 10-17 16:59:29.263: E/ExtMediaPlayer-JNI(22104): env-&amp;gt;IsInstanceOf fails 10-17 16:59:29.263: E/MediaPlayer-JNI(22104): JNIMediaPlayerFactory: bIsQCMediaPlayerPresent 0 10-18 00:25:40.894: E/MediaPlayer(28634): stop called in state 1 10-18 00:25:40.894: E/MediaPlayer(28634): error (-38, 0) 10-18 00:25:40.903: E/MediaPlayer(28634): Error (-38,0)  这两个错误log的具体原因不清楚，第一个貌似和权限相关。</description>
    </item>
    
    <item>
      <title>[Android NDK]Android.mk missing separator.Stop</title>
      <link>https://dawnarc.com/2016/10/android-ndkandroid.mk-missing-separator.stop/</link>
      <pubDate>Sat, 15 Oct 2016 15:30:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkandroid.mk-missing-separator.stop/</guid>
      <description> android NDK编译代码时，命令行提示错误：
jni/Android.mk:21: *** missing separator. Stop.
原因有以下几点： 1，$符号之前必须有一个空格，不能跟前面的字符连在一起。如果$是该行的第一个字符，前面可以不用空格。 例子（正常）：
LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS)  错误写法：
LOCAL_PATH :=$(call my-dir) include$(CLEAR_VARS)  2，每行结尾处不能有空格。 例子（正常）：
COMPILER_SRC_FILES := \  错误写法：
COMPILER_SRC_FILES := \  </description>
    </item>
    
    <item>
      <title>[Android NDK]STL linking issues (bug)</title>
      <link>https://dawnarc.com/2016/10/android-ndkstl-linking-issues-bug/</link>
      <pubDate>Sat, 15 Oct 2016 02:24:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkstl-linking-issues-bug/</guid>
      <description>NDK 1.2之后的版本已修复此bug，1.2及1.2之前的版本存在这个问题。但1.2之后的版本不再支持GCC。
原文： http://boguscoder.blogspot.jp/2013/08/android-ndk-stl-linking-issues-bug.html
ld.exe: libmoduleA.a(moduleA.o): in function std::priv::_String_base&amp;gt;::_M_allocate_block(unsigned int):/sources/cxx-stl/stlport/stlport/stl/_alloc.h:158: error: undefined reference to &amp;lsquo;std::_node_alloc::_M_allocate(unsigned int&amp;amp;)&amp;rsquo; ld.exe: libmoduleA.a(moduleA.o): in function std::priv::_String_base&amp;gt;::_M_allocate_block(unsigned int):/sources/cxx-stl/stlport/stlport/stl/_string.c:600: error: undefined reference to &amp;lsquo;std:stl_throw_length_error(char const*)&amp;rsquo; ld.exe: libmoduleA.a(moduleA.o): in function functionA():/sources/cxx-stl/stlport/stlport/stl/_alloc.h:161: error: undefined reference to &amp;lsquo;std::node_alloc::_M_deallocate(void*, unsigned int)&amp;lsquo;collect2: ld returned 1 exit status
Android.mk中添加库libstlport_static.a：
LOCAL_LDLIBS := -lmoduleA \ &amp;lt;NDK_PATH&amp;gt;/libstlport_static.a  如果是UE4工程编译Android，到android-ndk-r10e\sources\cxx-stl\stlport\libs\armeabi\下拷贝一个libstlport_static.a到你工程的库文件目录下即可。</description>
    </item>
    
    <item>
      <title>[Android NDK]fatal error &#39;backward_warning.h&#39; file not found</title>
      <link>https://dawnarc.com/2016/10/android-ndkfatal-error-backward_warning.h-file-not-found/</link>
      <pubDate>Sat, 15 Oct 2016 01:09:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkfatal-error-backward_warning.h-file-not-found/</guid>
      <description>android中使用hash_map时报错： fatal error: &#39;backward_warning.h&#39; file not found
解决办法： Android.mk添加宏定义
LOCAL_CFLAGS := -D_GLIBCXX_PERMIT_BACKWARD_HASH  如果是UE4项目编译android版本，在工程的Build.cs中添加：
Definitions.Add(&amp;quot;_GLIBCXX_PERMIT_BACKWARD_HASH&amp;quot;);  </description>
    </item>
    
    <item>
      <title>[UE4]客户端无法调用FindPathToLocationSynchronously函数的问题</title>
      <link>https://dawnarc.com/2016/06/ue4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8findpathtolocationsynchronously%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 Jun 2016 12:02:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/ue4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8findpathtolocationsynchronously%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>如果client-side执行UNavigationSystem::FindPathToLocationSynchronously()，会返回错误：
Error Accessed None &#39;CallFunc_FindPathToLocationSynchronously_ReturnValue2&#39; from node ReturnNode in blueprint GameController  原因： client-side默认关闭了寻路功能，需要启动，修改设置：Project Settings &amp;gt; Navigation System &amp;gt; bAllowClientSideNavigation
参考：https://answers.unrealengine.com/questions/222353/find-path-to-location-synchronously-not-working-on.html</description>
    </item>
    
    <item>
      <title>[UE4]UObject ConditionalBeginDestroy相关</title>
      <link>https://dawnarc.com/2016/05/ue4uobject-conditionalbegindestroy%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sat, 28 May 2016 16:43:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/05/ue4uobject-conditionalbegindestroy%E7%9B%B8%E5%85%B3/</guid>
      <description>UObject ConditionalBeginDestroy()导致无法第二次重新Load的问题 如果一个材质对象首次执行垃圾回收（ConditionalBeginDestroy是对BeginDestroy的封装，BeginDestroy是不管任何因素强制回收）：
UObject::ConditionalBeginDestroy()  或者：
UObject::BeginDestroy()  之后又需要再次加载该材质，那么调用LoadObject()时，第一个参数不能为NULL:
UObject* Obj = LoadObject&amp;lt;UObject&amp;gt;(NULL, Path);  因为这样只是在内存中扫描，不会从工程的资源Package文件中去加载(为什么首次这样执行可以加载成功？因为启动UE4Editor或程序首次启动时会加载被引用的资源)，所以这样不会加载成功，返回值为NULL。 如果要从工程资源文件中加载，那么需要手动new一个UObject，作为LoadObject的第一个参数：
UObject* Obj = NewObject&amp;lt;UTexture2D&amp;gt;(); LoadObject&amp;lt;UObject&amp;gt;(Obj, Path);  这样就能正确加载了。 但是这样有个问题：会发现，过几秒以后，再次使用这个UObject时会出现指针非法的错误，原因是刚刚自己New的UObject被引擎从内存中回收了。 如何禁止引擎对该UObject自动垃圾回收，而是我们自己手动执行？执行下AddToRoot：
Obj-&amp;gt;AddToRoot();  注：如果执行了AddToRoot()，那么退出程序前需要执行RemoveFromRoot()，否则在引擎在清理内存时会错误。(www.dawnarc.com)
如果一个UObject是SpawnActor创建出来的，那么执行Destroy()之后，再次执行Spawn是可以正常创建出来的。这点和LoadObject有区别。
ConditionalBeginDestroy()并不推荐在业务逻辑中使用 UE4官方论坛上，很多帖子或资料告诉你，如果要销毁对象，需要执行ConditionalBeginDestroy()。其实这个API不是给上层逻辑使用的，如果要销毁对象，只要保证该对象失去引用或者RemoveFromRoot()即可，否则就会出现上述问题，即：Destroy之后，无法第二次Load。但是这个问题只存在编辑器运行模式下，如果是打包版本（或者Play时选择下拉菜单：Standalone），即使Destroy()，第二次LoadObject()，第一个参数为NULL，也是可以正常加载的。
 DedicatedServer 中的问题 如果在 DedicatedServer 模式下，SpawnActor生成Actor，且这个Actor bReplicates 设置为true，执行 ConditionalBeginDestroy() ，一定时间后客户端会崩掉，但是使用 Destroy() 没问题。对于服务端生成的 Actor，销毁对象时绝对不要 ConditionalBeginDestroy()。
 DedicatedServer 模式下，SpawnActor生成出的 Actor，且这个Actor bReplicates 设置为true， 执行ConditionalBeginDestroy()时，一定时间后客户端会崩掉。
解决办法：
SpawnActor生成出的 Actor，且 AActor::bReplicates = true; ，销毁时，不要用ConditionalBeginDestroy()，而要用Destroy()。Standalone 模式貌似没这种限制。
崩溃日志：
Assertion failed: Index &amp;gt;= 0 [File:D:\Build\++UE4+Release-4.16+Compile\Sync\Engine\Source\Runtime\CoreUObject\Public\UObject/UObjectArray.h] [Line: 455] UE4Editor_Core!</description>
    </item>
    
  </channel>
</rss>