<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Error on 玄冬Wong</title>
    <link>https://dawnarc.com/tags/error/</link>
    <description>Recent content in Error on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 08 Mar 2017 23:14:40 +0800</lastBuildDate><atom:link href="https://dawnarc.com/tags/error/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[Windows]Epic Games Launcher Error Codes 2503, 2502</title>
      <link>https://dawnarc.com/2017/03/windowsepic-games-launcher-error-codes-2503-2502/</link>
      <pubDate>Wed, 08 Mar 2017 23:14:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/03/windowsepic-games-launcher-error-codes-2503-2502/</guid>
      <description>问题： 安装launcher时报错，error 2503 2502
解决办法： 管理员模式下的CMD中执行命令：
msiexec /package EpicGamesLauncherInstaller-2.12.24-3321064.msi参考： https://answers.unrealengine.com/questions/368475/epic-games-launcher-error-codes-2503-2502.html
东风渐绿西湖岸，雁已还、人来南归。—周密《高阳台》</description>
    </item>
    
    <item>
      <title>[UE4][C&#43;&#43;]不调用父类BeginDestroy()会导致的崩溃问题</title>
      <link>https://dawnarc.com/2016/11/ue4c-%E4%B8%8D%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BBbegindestroy%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</link>
      <pubDate>Tue, 01 Nov 2016 23:23:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/11/ue4c-%E4%B8%8D%E8%B0%83%E7%94%A8%E7%88%B6%E7%B1%BBbegindestroy%E4%BC%9A%E5%AF%BC%E8%87%B4%E7%9A%84%E5%B4%A9%E6%BA%83%E9%97%AE%E9%A2%98/</guid>
      <description>出现以下异常的原因是：重写了BeginDestroy()函数但没有在其内部执行Super::BeginDestroy()。
Fatal error: [File:D:\Build\++UE4+Release-4.13+Compile\Sync\Engine\Source\Runtime\CoreUObject\Private\UObject\Obj.cpp] [Line: 742] HPlayerController None.None:None.HPlayerController_0 failed to route BeginDestroyUE4Editor_Core!FDebug::AssertFailed() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\private\misc\outputdevice.cpp:421]UE4Editor_CoreUObject!UObject::ConditionalBeginDestroy() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\obj.cpp:742]UE4Editor_CoreUObject!CollectGarbageInternal() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\garbagecollection.cpp:1281]UE4Editor_CoreUObject!CollectGarbage() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\garbagecollection.cpp:1320]UE4Editor_UnrealEd!UEditorEngine::EndPlayMap() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:408]UE4Editor_LevelEditor!FLevelViewportLayout::~FLevelViewportLayout() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\leveleditor\private\levelviewportlayout.cpp:145]UE4Editor_LevelEditor!FLevelViewportLayout2x2::`scalar deleting destructor&#39;()UE4Editor_LevelEditor!FLevelViewportTabContent::~FLevelViewportTabContent()UE4Editor_LevelEditor!SharedPointerInternals::TReferenceControllerWithDeleter&amp;lt;FLevelViewportTabContent,SharedPointerInternals::DefaultDeleter&amp;lt;FLevelViewportTabContent&amp;gt; &amp;gt;::DestroyObject() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\templates\sharedpointerinternals.h:104]UE4Editor_LevelEditor!SViewportsOverlay::~SViewportsOverlay()UE4Editor_LevelEditor!SViewportsOverlay::`scalar deleting destructor&#39;()UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot()UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget()UE4Editor_Slate!SBorder::`vector deleting destructor&#39;()UE4Editor_SlateCore!TIndirectArray&amp;lt;SOverlay::FOverlaySlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474]UE4Editor_SlateCore!SOverlay::~SOverlay()UE4Editor_Slate!SOverlay::`scalar deleting destructor&#39;()UE4Editor_SlateCore!TIndirectArray&amp;lt;SBoxPanel::FSlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474]UE4Editor_SlateCore!SBoxPanel::~SBoxPanel()UE4Editor_Slate!SVerticalBox::`scalar deleting destructor&#39;()UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot()UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget()UE4Editor_Slate!SDockingTabStack::`vector deleting destructor&#39;()UE4Editor_SlateCore!FSlotBase::~FSlotBase() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\slatecore\private\slotbase.cpp:34]UE4Editor_Slate!TIndirectArray&amp;lt;SSplitter::FSlot,FDefaultAllocator&amp;gt;::DestructAndFreeItems() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\public\containers\array.h:3474]UE4Editor_Slate!SSplitter::~SSplitter()UE4Editor_Slate!SSplitter::`vector deleting destructor&#39;()UE4Editor_SlateCore!FSimpleSlot::~FSimpleSlot()UE4Editor_SlateCore!SCompoundWidget::~SCompoundWidget()UE4Editor_Slate!SDockingSplitter::`vector deleting destructor&#39;()UE4Editor_SlateCore!</description>
    </item>
    
    <item>
      <title>[Android NDK]错误log：ExtMediaPlayer-JNI(22104) env-IsInstanceOf fails</title>
      <link>https://dawnarc.com/2016/10/android-ndk%E9%94%99%E8%AF%AFlogextmediaplayer-jni22104-env-isinstanceof-fails/</link>
      <pubDate>Mon, 17 Oct 2016 15:35:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndk%E9%94%99%E8%AF%AFlogextmediaplayer-jni22104-env-isinstanceof-fails/</guid>
      <description>如果你的android app出现以下两种错误log提示，并不影响你的app运行，如果你的app崩溃，可以忽略下面两种log。
10-17 16:59:29.263: E/ExtMediaPlayer-JNI(22104): env-&amp;gt;IsInstanceOf fails10-17 16:59:29.263: E/MediaPlayer-JNI(22104): JNIMediaPlayerFactory: bIsQCMediaPlayerPresent 010-17 16:59:29.263: E/ExtMediaPlayer-JNI(22104): env-&amp;gt;IsInstanceOf fails10-17 16:59:29.263: E/MediaPlayer-JNI(22104): JNIMediaPlayerFactory: bIsQCMediaPlayerPresent 010-18 00:25:40.894: E/MediaPlayer(28634): stop called in state 110-18 00:25:40.894: E/MediaPlayer(28634): error (-38, 0)10-18 00:25:40.903: E/MediaPlayer(28634): Error (-38,0)这两个错误log的具体原因不清楚，第一个貌似和权限相关。</description>
    </item>
    
    <item>
      <title>[Android NDK]Android.mk missing separator.Stop</title>
      <link>https://dawnarc.com/2016/10/android-ndkandroid.mk-missing-separator.stop/</link>
      <pubDate>Sat, 15 Oct 2016 15:30:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkandroid.mk-missing-separator.stop/</guid>
      <description>android NDK编译代码时，命令行提示错误：
jni/Android.mk:21: *** missing separator. Stop.
原因有以下几点： 1，$符号之前必须有一个空格，不能跟前面的字符连在一起。如果$是该行的第一个字符，前面可以不用空格。 例子（正常）：
LOCAL_PATH := $(call my-dir) include $(CLEAR_VARS) 错误写法：
LOCAL_PATH :=$(call my-dir) include$(CLEAR_VARS) 2，每行结尾处不能有空格。 例子（正常）：
COMPILER_SRC_FILES := \错误写法：
COMPILER_SRC_FILES := \ </description>
    </item>
    
    <item>
      <title>[Android NDK]STL linking issues (bug)</title>
      <link>https://dawnarc.com/2016/10/android-ndkstl-linking-issues-bug/</link>
      <pubDate>Sat, 15 Oct 2016 02:24:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkstl-linking-issues-bug/</guid>
      <description>NDK 1.2之后的版本已修复此bug，1.2及1.2之前的版本存在这个问题。但1.2之后的版本不再支持GCC。
原文： http://boguscoder.blogspot.jp/2013/08/android-ndk-stl-linking-issues-bug.html
ld.exe: libmoduleA.a(moduleA.o): in function std::priv::_String_base&amp;lt;char, std::allocator &amp;gt;::_M_allocate_block(unsigned int):/sources/cxx-stl/stlport/stlport/stl/_alloc.h:158: error: undefined reference to &amp;lsquo;std::_node_alloc::_M_allocate(unsigned int&amp;amp;)&amp;rsquo; ld.exe: libmoduleA.a(moduleA.o): in function std::priv::_String_base&amp;lt;char, std::allocator &amp;gt;::_M_allocate_block(unsigned int):/sources/cxx-stl/stlport/stlport/stl/_string.c:600: error: undefined reference to &amp;lsquo;std:__stl_throw_length_error(char const*)&amp;rsquo; ld.exe: libmoduleA.a(moduleA.o): in function functionA():/sources/cxx-stl/stlport/stlport/stl/_alloc.h:161: error: undefined reference to &amp;lsquo;std::__node_alloc::_M_deallocate(void*, unsigned int)&amp;lsquo;collect2: ld returned 1 exit status
Android.mk中添加库libstlport_static.a：
LOCAL_LDLIBS := -lmoduleA \&amp;lt;NDK_PATH&amp;gt;/libstlport_static.a如果是UE4工程编译Android，到android-ndk-r10e\sources\cxx-stl\stlport\libs\armeabi\下拷贝一个libstlport_static.a到你工程的库文件目录下即可。</description>
    </item>
    
    <item>
      <title>[Android NDK]fatal error &#39;backward_warning.h&#39; file not found</title>
      <link>https://dawnarc.com/2016/10/android-ndkfatal-error-backward_warning.h-file-not-found/</link>
      <pubDate>Sat, 15 Oct 2016 01:09:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/10/android-ndkfatal-error-backward_warning.h-file-not-found/</guid>
      <description>android中使用hash_map时报错： fatal error: &#39;backward_warning.h&#39; file not found
解决办法： Android.mk添加宏定义
LOCAL_CFLAGS := -D_GLIBCXX_PERMIT_BACKWARD_HASH 如果是UE4项目编译android版本，在工程的Build.cs中添加：
Definitions.Add(&amp;quot;_GLIBCXX_PERMIT_BACKWARD_HASH&amp;quot;);</description>
    </item>
    
    <item>
      <title>[UE4]客户端无法调用FindPathToLocationSynchronously函数的问题</title>
      <link>https://dawnarc.com/2016/06/ue4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8findpathtolocationsynchronously%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</link>
      <pubDate>Mon, 13 Jun 2016 12:02:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/ue4%E5%AE%A2%E6%88%B7%E7%AB%AF%E6%97%A0%E6%B3%95%E8%B0%83%E7%94%A8findpathtolocationsynchronously%E5%87%BD%E6%95%B0%E7%9A%84%E9%97%AE%E9%A2%98/</guid>
      <description>如果client-side执行UNavigationSystem::FindPathToLocationSynchronously()，会返回错误：
Error Accessed None &#39;CallFunc_FindPathToLocationSynchronously_ReturnValue2&#39; from node ReturnNode in blueprint GameController原因： client-side默认关闭了寻路功能，需要启动，修改设置：Project Settings &amp;gt; Navigation System &amp;gt; bAllowClientSideNavigation
参考：https://answers.unrealengine.com/questions/222353/find-path-to-location-synchronously-not-working-on.html</description>
    </item>
    
    <item>
      <title>[UE4]UObject ConditionalBeginDestroy相关</title>
      <link>https://dawnarc.com/2016/05/ue4uobject-conditionalbegindestroy%E7%9B%B8%E5%85%B3/</link>
      <pubDate>Sat, 28 May 2016 16:43:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/05/ue4uobject-conditionalbegindestroy%E7%9B%B8%E5%85%B3/</guid>
      <description>UObject ConditionalBeginDestroy()导致无法第二次重新Load的问题 现象：
如果一个材质对象首次执行垃圾回收（ConditionalBeginDestroy是对BeginDestroy的封装，BeginDestroy是不管任何因素强制回收）：
UObject::ConditionalBeginDestroy()或者：
UObject::BeginDestroy()之后又需要再次加载该材质，那么调用LoadObject()时，第一个参数不能为NULL:
UObject* Obj = LoadObject&amp;lt;UObject&amp;gt;(NULL, Path);原因：
在编辑器模式下，通过LoadObject加载出来的对象，如果执行了Destroy，那么在不重启编辑器模式的情况下，第二次执行LoadObject&amp;lt;UObject&amp;gt;(NULL, Path);会返回NULL，即使在编辑器模式下重新启动游戏也返回NULL
解决办法：
上述情况只存在编辑器模式下，如果是打包版本，即使一开始 Destroy，第二次 LoadObject 的时候仍然可以加载成功。
如果非得希望在编辑器模式下，Destroy资源之后仍然能够正常第二次 LoadObject 该资源，方式如下：
手动new一个UObject，作为LoadObject的第一个参数
UObject* Obj = NewObject&amp;lt;UTexture2D&amp;gt;();LoadObject&amp;lt;UObject&amp;gt;(Obj, Path);这样就能正确加载了。
通过上述表现可以推算出，编辑器和引擎的Runtime公用了同一个对象
且该对象没有随着编辑器模式下退出游戏而被清理； 且该对象在编辑器和Runtime分别存在一个是否已销毁的标记； 且该对象在PIE（Play In Editor）模式下 Destroy 后，并没有标记该对象在编辑器中已非法； 所以在PIE模式下第二次 LoadObject 时认为该对象还存在，并且直接返回了这个已经被Destroy的空对象。
如果UE4资源管理的引擎代码写的足够好，对于Destroy对象的操作，应该提供两个版本：一个PIE、一个Game Runtime。
内存持久化 (Memory Persistence) 上述问题中，即使在第二次加载时手动 NewObject 创建一个对象，仍然存在问题：会发现，过几秒以后，再次使用这个UObject时会出现指针非法的错误，原因是刚刚自己New的UObject被引擎从内存中回收了。 如何禁止引擎对该UObject自动垃圾回收，而是我们自己手动执行？执行下AddToRoot：
Obj-&amp;gt;AddToRoot();注：如果执行了AddToRoot()，那么退出程序前需要执行RemoveFromRoot()，否则在引擎在清理内存时会错误。
如果一个UObject是SpawnActor创建出来的，那么执行Destroy()之后，再次执行Spawn是可以正常创建出来的。这点和LoadObject有区别。 ConditionalBeginDestroy()并不推荐在业务逻辑中使用 UE4官方论坛上，很多帖子或资料告诉你，如果要销毁对象，需要执行ConditionalBeginDestroy()。其实这个API不是给上层逻辑使用的，如果要销毁对象，只要保证该对象失去引用或者RemoveFromRoot()即可，否则就会出现上述问题，即：Destroy之后，无法第二次Load。但是这个问题只存在编辑器运行模式下，如果是打包版本（或者Play时选择下拉菜单：Standalone），即使Destroy()，第二次LoadObject()，第一个参数为NULL，也是可以正常加载的。
DedicatedServer 中的问题 如果在 DedicatedServer 模式下，SpawnActor生成Actor，且这个Actor bReplicates 设置为true，执行 ConditionalBeginDestroy() ，一定时间后客户端会崩掉，但是使用 Destroy() 没问题。对于服务端生成的 Actor，销毁对象时绝对不要 ConditionalBeginDestroy()。</description>
    </item>
    
  </channel>
</rss>
