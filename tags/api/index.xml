<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Api on 玄冬Wong</title>
    <link>http://www.dawnarc.com/tags/api/</link>
    <description>Recent content in Api on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Mon, 15 May 2017 23:31:02 +0800</lastBuildDate>
    
	<atom:link href="http://www.dawnarc.com/tags/api/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[UE4]C&#43;&#43;创建BoxCollision(BoxComponent)并注册Overlap和Hit事件回调函数</title>
      <link>http://www.dawnarc.com/2017/05/ue4c--%E5%88%9B%E5%BB%BAboxcollisionboxcomponent%E5%B9%B6%E6%B3%A8%E5%86%8Coverlap%E5%92%8Chit%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</link>
      <pubDate>Mon, 15 May 2017 23:31:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2017/05/ue4c--%E5%88%9B%E5%BB%BAboxcollisionboxcomponent%E5%B9%B6%E6%B3%A8%E5%86%8Coverlap%E5%92%8Chit%E4%BA%8B%E4%BB%B6%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0/</guid>
      <description>keywords: UE4、Overlap、Hit、Event、Callback、C++、Blueprint、Box Collision、BoxComponent、SphereComponent、Trace Channel、碰撞
BoxComponent的Overlap事件 1，C++中的代码编写 这里我们演示的例子，是在角色身上创建一个BoxComponent，假设角色的C++ class叫AMyCharacter。 MyCharacter.h头文件中定义：
//Box对象 UBoxComponent* CollisionMesh; //OverlapBegin事件的回调函数，注意函数签名！ UFUNCTION() void OnTestOverlapBegin(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const FHitResult &amp;amp; SweepResult); //OverlapEnd事件的回调函数，注意函数签名！ UFUNCTION() void OnTestOverlapEnd(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex);  回调函数一定要加UFUNCTION()，否则无法注册成功，因为注册函数时使用了UE4编译器的反射。
 MyCharacter.cpp的构造函数中：
//创建BoxComponent CollisionMesh = CreateDefaultSubobject&amp;lt;UBoxComponent&amp;gt;(TEXT(&amp;quot;TestCollision&amp;quot;)); CollisionMesh-&amp;gt;SetBoxExtent(FVector(200.f, 200.f, 96.f)); CollisionMesh-&amp;gt;bDynamicObstacle = true; CollisionMesh-&amp;gt;SetupAttachment(GetRootComponent()); //如果需要Overlap事件，将bGenerateOverlapEvents设置为true。如果不设置，默认也为true。 CollisionMesh-&amp;gt;bGenerateOverlapEvents = true; //注意：要触发Overlap事件，SetCollisionResponseToAllChannels要么不设置，要么设置为ECR_Overlap。 CollisionMesh-&amp;gt;SetCollisionResponseToAllChannels(ECR_Overlap); /*CollisionMesh-&amp;gt;SetCollisionResponseToChannel(ECC_WorldStatic, ECR_Block); CollisionMesh-&amp;gt;SetCollisionResponseToChannel(ECC_WorldDynamic, ECR_Block); CollisionMesh-&amp;gt;SetCollisionResponseToChannel(ECC_Pawn, ECR_Block); CollisionMesh-&amp;gt;SetNotifyRigidBodyCollision(true); CollisionMesh-&amp;gt;SetSimulatePhysics(true);*/ //要触发Overlap事件，碰对对象需要勾选属性：Generate Overlap Events FScriptDelegate DelegateBegin; DelegateBegin.</description>
    </item>
    
    <item>
      <title>[UE4][C&#43;&#43;]如何获取鼠标点击时的物体对象</title>
      <link>http://www.dawnarc.com/2016/11/ue4c--%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%97%B6%E7%9A%84%E7%89%A9%E4%BD%93%E5%AF%B9%E8%B1%A1/</link>
      <pubDate>Thu, 10 Nov 2016 22:33:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/11/ue4c--%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96%E9%BC%A0%E6%A0%87%E7%82%B9%E5%87%BB%E6%97%B6%E7%9A%84%E7%89%A9%E4%BD%93%E5%AF%B9%E8%B1%A1/</guid>
      <description>注册回调函数：
MyObject-&amp;gt;OnClicked.AddDynamic(this, &amp;amp;AExampleActor::DoAthing);  </description>
    </item>
    
    <item>
      <title>[UE4][UE_LOG用法</title>
      <link>http://www.dawnarc.com/2016/11/ue4ue_log%E7%94%A8%E6%B3%95/</link>
      <pubDate>Thu, 10 Nov 2016 22:33:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/11/ue4ue_log%E7%94%A8%E6%B3%95/</guid>
      <description> 三种方式：
方式1：GLog GLog-&amp;gt;Log(&amp;quot;Does something&amp;quot;);  方式2：UE_LOG(LogTemp) UE_LOG(LogTemp, Log, TEXT(&amp;quot;%d&amp;quot;), 1111); UE_LOG(LogTemp, Warning, TEXT(&amp;quot;%d&amp;quot;), 1111);  方式3：自定义log 转载自：http://www.cnblogs.com/pengyingh/articles/5472998.html
头文件中加入：
#pragma once #include &amp;quot;GameFramework/Actor.h&amp;quot; #include &amp;quot;FloatingActor.generated.h&amp;quot; DECLARE_LOG_CATEGORY_EXTERN(YourLog, Log, All);  cpp文件中加入：
#include &amp;quot;FirstProject.h&amp;quot; #include &amp;quot;FloatingActor.h&amp;quot; DEFINE_LOG_CATEGORY(YourLog);  使用
UE_LOG(YourLog, Warning, TEXT(&amp;quot;Test UE_LOG %d&amp;quot;), rand());  三种方式的输出结果 Does something LogTemp: 1111 LogTemp: Warning: 1111（黄色）  </description>
    </item>
    
    <item>
      <title>[UE4]AddToRoot()要与RemoveFromRoot成对出现</title>
      <link>http://www.dawnarc.com/2016/10/ue4addtoroot%E8%A6%81%E4%B8%8Eremovefromroot%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0/</link>
      <pubDate>Wed, 19 Oct 2016 15:33:40 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/10/ue4addtoroot%E8%A6%81%E4%B8%8Eremovefromroot%E6%88%90%E5%AF%B9%E5%87%BA%E7%8E%B0/</guid>
      <description>如果对某个UObject执行了AddToRoot()，那么需要在该UObject所属的上级UOject销毁前，执行RemoveFromRoot()，否则当程序退出时，会出现崩溃，崩溃堆栈：
Assertion failed: !IsRooted() [File:d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\public\uobject\UObjectBaseUtility.h] [Line: 135] UE4Editor_Core!FDebug::AssertFailed() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\core\private\misc\outputdevice.cpp:421] UE4Editor_UnrealEd!&amp;lt;lambda_26419e543909ee92ebfb672b1e9c08dc&amp;gt;::operator()() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:384] UE4Editor_CoreUObject!ForEachObjectWithOuter() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\coreuobject\private\uobject\uobjecthash.cpp:678] UE4Editor_UnrealEd!UEditorEngine::EndPlayMap() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\playlevel.cpp:380] UE4Editor_UnrealEd!UEditorEngine::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\editorengine.cpp:1653] UE4Editor_UnrealEd!UUnrealEdEngine::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\editor\unrealed\private\unrealedengine.cpp:371] UE4Editor!FEngineLoop::Tick() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\launchengineloop.cpp:2834] UE4Editor!GuardedMain() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\launch.cpp:156] UE4Editor!GuardedMainWrapper() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\windows\launchwindows.cpp:126] UE4Editor!WinMain() [d:\build\++ue4+release-4.13+compile\sync\engine\source\runtime\launch\private\windows\launchwindows.cpp:202] UE4Editor!__scrt_common_main_seh() [f:\dd\vctools\crt\vcstartup\src\startup\exe_common.inl:264] kernel32 ntdll  </description>
    </item>
    
    <item>
      <title>[UE4]如何隐藏Actor</title>
      <link>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8Factor/</link>
      <pubDate>Wed, 12 Oct 2016 20:21:40 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E9%9A%90%E8%97%8Factor/</guid>
      <description>三种方式：
1，MyActor-&amp;gt;bHidden = true;
2, MyActor-&amp;gt;GetMesh()-&amp;gt;SetVisibility(false);
3，MyActor-&amp;gt;SetActorHiddenInGame(true);</description>
    </item>
    
    <item>
      <title>[UE4]如何禁用角色的刚体碰撞检测Collision</title>
      <link>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E8%A7%92%E8%89%B2%E7%9A%84%E5%88%9A%E4%BD%93%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8Bcollision/</link>
      <pubDate>Wed, 12 Oct 2016 20:15:40 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E7%A6%81%E7%94%A8%E8%A7%92%E8%89%B2%E7%9A%84%E5%88%9A%E4%BD%93%E7%A2%B0%E6%92%9E%E6%A3%80%E6%B5%8Bcollision/</guid>
      <description>通常的做法是：
MyCharacter-&amp;gt;SetActorEnableCollision(false);  这样设置以后，角色就可以忽视一切障碍物或者刚体来进行移动了。
另外Mesh也提供了接口来禁用刚体，但是一般情况都是将刚体加到角色蓝图中，而不是加载角色的Mesh上，所以这种不适用常规情况。
MyCharacter-&amp;gt;GetMesh()-&amp;gt;SetCollisionEnabled(ECollisionEnabled::NoCollision);  </description>
    </item>
    
    <item>
      <title>[UE4]如何替换角色Mesh上的Material材质</title>
      <link>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E8%A7%92%E8%89%B2mesh%E4%B8%8A%E7%9A%84material%E6%9D%90%E8%B4%A8/</link>
      <pubDate>Tue, 11 Oct 2016 02:21:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/10/ue4%E5%A6%82%E4%BD%95%E6%9B%BF%E6%8D%A2%E8%A7%92%E8%89%B2mesh%E4%B8%8A%E7%9A%84material%E6%9D%90%E8%B4%A8/</guid>
      <description>.h (located in pawn header file and assigned in Blueprint editor)
UPROPERTY(EditAnywhere) TArray&amp;lt;UMaterialInterface*&amp;gt; Materials;  .h (located in pawn manager responsible for spawning them)
TSubclassOf&amp;lt;class AMyPawn&amp;gt; PawnClass;  .cpp
FVector spawnLocation = FVector(0.0f, 0.0f, 0.0f); FRotator spawnRotation = FRotator::ZeroRotator; AMyPawn* pawn = GetWorld()-&amp;gt;SpawnActor&amp;lt;AMyPawn&amp;gt;(PawnClass, spawnLocation, spawnRotation); if (pawn != nullptr) { AMyPawn* defaultPawn = PawnClass.GetDefaultObject(); int32 materialCount = defaultPawn-&amp;gt;Materials.Num(); int m = FMath::RandRange(0, materialCount - 1); const TArray&amp;lt;UActorComponent*&amp;gt;&amp;amp; theComponents = pawn-&amp;gt;GetComponents(); int32 componentCount = theComponents.</description>
    </item>
    
    <item>
      <title>[UE4]Controller.StopMovement()和MovementComponent.StopMovementImmediately()的区别</title>
      <link>http://www.dawnarc.com/2016/10/ue4controller.stopmovement%E5%92%8Cmovementcomponent.stopmovementimmediately%E7%9A%84%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sat, 01 Oct 2016 23:46:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/10/ue4controller.stopmovement%E5%92%8Cmovementcomponent.stopmovementimmediately%E7%9A%84%E5%8C%BA%E5%88%AB/</guid>
      <description>Controller.StopMovement()和MovementComponent.StopMovementImmediately()的区别 前者只执行：
PathFollowingComp-&amp;gt;AbortMove(*this, FPathFollowingResultFlags::MovementStop);  后者先执行：
Velocity = FVector::ZeroVector;  接着再执行：
PathFollowingComp-&amp;gt;AbortMove(*this, FPathFollowingResultFlags::MovementStop);  </description>
    </item>
    
    <item>
      <title>[UE4]如何遍历场景中的所有Actor和Object(C&#43;&#43;)</title>
      <link>http://www.dawnarc.com/2016/09/ue4%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89actor%E5%92%8Cobjectc--/</link>
      <pubDate>Thu, 29 Sep 2016 19:43:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/09/ue4%E5%A6%82%E4%BD%95%E9%81%8D%E5%8E%86%E5%9C%BA%E6%99%AF%E4%B8%AD%E7%9A%84%E6%89%80%E6%9C%89actor%E5%92%8Cobjectc--/</guid>
      <description>原文： https://wiki.unrealengine.com/Iterators:_Object_%26_Actor_Iterators,_Optional_Class_Scope_For_Faster_Search
遍历所有SkeletalMeshComponent
for ( TObjectIterator&amp;lt;USkeletalMeshComponent&amp;gt; Itr; Itr; ++Itr ) { // Access the subclass instance with the * or -&amp;gt; operators. USkeletalMeshCompoment *Component = *Itr; ClientMessage(Itr-&amp;gt;GetName()); }  遍历所有StaticMeshActor
for (TActorIterator&amp;lt;AStaticMeshActor&amp;gt; ActorItr(GetWorld()); ActorItr; ++ActorItr) { // Same as with the Object Iterator, access the subclass instance with the * or -&amp;gt; operators. AStaticMeshActor *Mesh = *ActorItr; ClientMessage(ActorItr-&amp;gt;GetName()); ClientMessage(ActorItr-&amp;gt;GetActorLocation().ToString()); }  遍历所有Character
for (TActorIterator&amp;lt;ACharacter&amp;gt; ActorItr(GetWorld()); ActorItr; ++ActorItr) { if (ActorItr-&amp;gt;GetName().</description>
    </item>
    
    <item>
      <title>[UE4]播放Montage动画时让动作停留在最后一帧</title>
      <link>http://www.dawnarc.com/2016/09/ue4%E6%92%AD%E6%94%BEmontage%E5%8A%A8%E7%94%BB%E6%97%B6%E8%AE%A9%E5%8A%A8%E4%BD%9C%E5%81%9C%E7%95%99%E5%9C%A8%E6%9C%80%E5%90%8E%E4%B8%80%E5%B8%A7/</link>
      <pubDate>Thu, 15 Sep 2016 03:12:40 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/09/ue4%E6%92%AD%E6%94%BEmontage%E5%8A%A8%E7%94%BB%E6%97%B6%E8%AE%A9%E5%8A%A8%E4%BD%9C%E5%81%9C%E7%95%99%E5%9C%A8%E6%9C%80%E5%90%8E%E4%B8%80%E5%B8%A7/</guid>
      <description> 三种方式
方式1： 在想要冻结的那一帧内，将SkeletonComponent的GlobalAnimRateScale属性设置为0。 比如想要角色的骨骼定格在第三帧，那么就在动画播放到第三帧的时候将该属性设置为0。
ACharacter::GetMesh()-&amp;gt;GlobalAnimRateScale = 0.f;  方式2: ACharacter::GetMesh()-&amp;gt;bNoSkeletonUpdate = true;  方式3： ACharacter::GetMesh()-&amp;gt;bPauseAnims = true;  注意：正常播放完AnimSequence时，只要不是设置为循环播放，播放完以后会自动停留在最后一帧。只有播放Montage时才需要设置以上属性。
 </description>
    </item>
    
    <item>
      <title>[UE4]中文字符的FString和wchar_t数组之间的转换</title>
      <link>http://www.dawnarc.com/2016/09/ue4%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%9A%84fstring%E5%92%8Cwchar_t%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</link>
      <pubDate>Sun, 11 Sep 2016 02:41:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/09/ue4%E4%B8%AD%E6%96%87%E5%AD%97%E7%AC%A6%E7%9A%84fstring%E5%92%8Cwchar_t%E6%95%B0%E7%BB%84%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2/</guid>
      <description>代码：
FString str(TEXT(&amp;quot;笑傲江湖DA&amp;quot;)); const wchar_t* s1 = *str; int LenW = wcslen(s1); int LenC = LenW * 2; char* buf = new char[LenC + 1](); memcpy(buf, s1, LenC); wchar_t* buf2 = new wchar_t[LenC/2 + 1](); memcpy(buf2, buf, LenC);  </description>
    </item>
    
    <item>
      <title>[UE4]如何获取FString转换后char之后的长度</title>
      <link>http://www.dawnarc.com/2016/09/ue4%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96fstring%E8%BD%AC%E6%8D%A2%E5%90%8Echar%E4%B9%8B%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6/</link>
      <pubDate>Sat, 10 Sep 2016 17:15:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/09/ue4%E5%A6%82%E4%BD%95%E8%8E%B7%E5%8F%96fstring%E8%BD%AC%E6%8D%A2%E5%90%8Echar%E4%B9%8B%E5%90%8E%E7%9A%84%E9%95%BF%E5%BA%A6/</guid>
      <description>比如用TCHAR_TO_ANSI()将tchar转换为char之后，char的长度如何计算？ 使用FTCHARToANSI::Length()，示例如下：
FTCHARToANSI Convert(*String); Ar-&amp;gt;Serialize((ANSICHAR*)Convert, Convert.Length());  参考自：https://docs.unrealengine.com/latest/INT/Programming/UnrealArchitecture/StringHandling/CharacterEncoding/index.html</description>
    </item>
    
    <item>
      <title>[UE4]如何启用Detour Crowd AI Controller(群组移动时的绕路问题)</title>
      <link>http://www.dawnarc.com/2016/07/ue4%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8detour-crowd-ai-controller%E7%BE%A4%E7%BB%84%E7%A7%BB%E5%8A%A8%E6%97%B6%E7%9A%84%E7%BB%95%E8%B7%AF%E9%97%AE%E9%A2%98/</link>
      <pubDate>Wed, 27 Jul 2016 19:39:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/07/ue4%E5%A6%82%E4%BD%95%E5%90%AF%E7%94%A8detour-crowd-ai-controller%E7%BE%A4%E7%BB%84%E7%A7%BB%E5%8A%A8%E6%97%B6%E7%9A%84%E7%BB%95%E8%B7%AF%E9%97%AE%E9%A2%98/</guid>
      <description> 老版本中需要手动写C++来设置CrowManagerClass，新版本中只需要在Project Settings中设置。
老版本 蓝图中叫做：Detour Crowd AI Controller C++代码中叫做：UCrowdFollowingComponent，在AIController的构造函数中设置即可
头文件：
MyAIController(const FObjectInitializer&amp;amp; ObjectInitializer = FObjectInitializer::Get());  cpp：
MyAIController::MyAIController(const FObjectInitializer&amp;amp; ObjectInitializer) : Super(ObjectInitializer.SetDefaultSubobjectClass&amp;lt;UCrowdFollowingComponent&amp;gt;(TEXT(&amp;quot;PathFollowingComponent&amp;quot;))) { }  新版本 Project Settings -》Engine -》 Navigation System -》 Crow Manager Class
  官方doc： FCrowdAvoidanceConfig https://docs.unrealengine.com/latest/INT/API/Runtime/AIModule/Navigation/FCrowdAvoidanceConfig/index.html
注意事项： 使用UCrowdFollowingComponent时必须禁用RVO避让模式，否则无法生效：
//默认是关闭的 GetCharacterMovement()-&amp;gt;bUseRVOAvoidance = false;  </description>
    </item>
    
    <item>
      <title>[UE4][线性代数]已知方向向量，求该向量与空间坐标轴的夹角</title>
      <link>http://www.dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%B7%B2%E7%9F%A5%E6%96%B9%E5%90%91%E5%90%91%E9%87%8F%E6%B1%82%E8%AF%A5%E5%90%91%E9%87%8F%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E5%A4%B9%E8%A7%92/</link>
      <pubDate>Wed, 06 Jul 2016 17:30:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%B7%B2%E7%9F%A5%E6%96%B9%E5%90%91%E5%90%91%E9%87%8F%E6%B1%82%E8%AF%A5%E5%90%91%E9%87%8F%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E5%A4%B9%E8%A7%92/</guid>
      <description>原始的数学公式不列举了，需要的话找个Math库看下源码。这里以UE4的API说明：
情况一：已知两个空间向量的角角 已知空间中两个点FVector V1, V2，方向向量V3 = V2 - V1，求V3与空间坐标的夹角：
FRotator R = (V2 - V1).Rotation();  情况二：单个向量与世界坐标的夹角 已知方向向量Vector V1，求V1与空间坐标轴的夹角Rotator R1：即将Vector转换为Rotator
FRotator R1 = FVector(100.f, 100.f, 0.f).Rotation(); FRotator R2 = FVector(-100.f, -100.f, 0.f).Rotation(); FRotator R3 = FVector(100.f, 0.f, 0.f).Rotation(); FRotator R4 = FVector(0.f, 100.f, 0.f).Rotation();  结果分别是：
R1 = {Pitch=0.0 Yaw=45.0 Roll=0.0 } R2 = {Pitch=0.0 Yaw=-135.0 Roll=0.0 } R3 = {Pitch=0.0 Yaw=0.0 Roll=0.0 } R4 = {Pitch=0.0 Yaw=90.0 Roll=0.0 }  FVector::Rotation()函数的内部实现（局部）：</description>
    </item>
    
    <item>
      <title>[UE4]线性代数与空间几何相关的API</title>
      <link>http://www.dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9A%84api/</link>
      <pubDate>Thu, 23 Jun 2016 23:35:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%87%A0%E4%BD%95%E7%9B%B8%E5%85%B3%E7%9A%84api/</guid>
      <description>检测一个点是否在一个多边形(或矩形)的内部(2D和3D)
FBox2D::IsInside(const FVector2D&amp;amp; TestPoint) FBox::IsInside(const FVector&amp;amp; TestPoint) FIntRect::Contains( FIntPoint P )  </description>
    </item>
    
    <item>
      <title>[UE4][线性代数]如何检测某个点是否在矩形范围内</title>
      <link>http://www.dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E8%8C%83%E5%9B%B4%E5%86%85/</link>
      <pubDate>Thu, 23 Jun 2016 15:15:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E8%8C%83%E5%9B%B4%E5%86%85/</guid>
      <description>代码：
FBox2D::IsInside(const FVector2D&amp;amp; TestPoint) FBox::IsInside(const FVector&amp;amp; TestPoint) FIntRect::Contains( FIntPoint P )  </description>
    </item>
    
    <item>
      <title>[UE4]寻路移动结束时的回调事件</title>
      <link>http://www.dawnarc.com/2016/06/ue4%E5%AF%BB%E8%B7%AF%E7%A7%BB%E5%8A%A8%E7%BB%93%E6%9D%9F%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E4%BA%8B%E4%BB%B6/</link>
      <pubDate>Tue, 21 Jun 2016 12:05:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4%E5%AF%BB%E8%B7%AF%E7%A7%BB%E5%8A%A8%E7%BB%93%E6%9D%9F%E6%97%B6%E7%9A%84%E5%9B%9E%E8%B0%83%E4%BA%8B%E4%BB%B6/</guid>
      <description>代码：
UPathFollowingComponent::OnMoveFinished  </description>
    </item>
    
    <item>
      <title>[UE4]NavigationSystem寻路相关的API</title>
      <link>http://www.dawnarc.com/2016/06/ue4navigationsystem%E5%AF%BB%E8%B7%AF%E7%9B%B8%E5%85%B3%E7%9A%84api/</link>
      <pubDate>Tue, 21 Jun 2016 12:02:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4navigationsystem%E5%AF%BB%E8%B7%AF%E7%9B%B8%E5%85%B3%E7%9A%84api/</guid>
      <description>检测某个坐标点是否在navmesh内，即可以作为寻路的坐标点。 UNavigationSystem::TestPathSync 实例用法：
UNavigationSystem* const NavSys = GetWorld()-&amp;gt;GetNavigationSystem(); const ANavigationData* NavData = NavSys-&amp;gt;GetNavDataForProps(YourCharacter-&amp;gt;GetNavAgentPropertiesRef()); FPathFindingQuery Query1(YourCharacter, *NavData, YourCharacter-&amp;gt;GetNavAgentLocation(), TestLocation); bool qrs1 = NavSys-&amp;gt;TestPathSync(Query1);  UNavigationSystem::FindPathSync也可以判断，但是他会返回寻路结果，效率上没有TestPathSync快。 其他的API还有：
UNavigationSystem::ProjectPointToNavigation  </description>
    </item>
    
    <item>
      <title>[UE4]Movement相关的API</title>
      <link>http://www.dawnarc.com/2016/06/ue4movement%E7%9B%B8%E5%85%B3%E7%9A%84api/</link>
      <pubDate>Sun, 19 Jun 2016 17:33:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4movement%E7%9B%B8%E5%85%B3%E7%9A%84api/</guid>
      <description> 如何停止正在移动的Pawn AController::StopMovement()  修改重力加速度(Gravity)  编辑器中设置全局重力加速度
Project Settings -》 Engine -》 Physics -》 Default Physics Settings -》 Default Gravity Z。
 运行时runtime期间设置全局重力加速度：
AWorldSettings* MyWorldSetting=GetWorldSettings(); MyWorldSetting-&amp;gt;bGlobalGravitySet=true; MyWorldSetting-&amp;gt;GlobalGravityZ = 900.f;  设置单个角色的重力加速度（倍率）
MyCharacter-&amp;gt;GetCharacterMovement()-&amp;gt;GravityScale = 100.f   </description>
    </item>
    
    <item>
      <title>[UE4]移动物体的几种方法</title>
      <link>http://www.dawnarc.com/2016/06/ue4%E7%A7%BB%E5%8A%A8%E7%89%A9%E4%BD%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 17 Jun 2016 13:17:40 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/06/ue4%E7%A7%BB%E5%8A%A8%E7%89%A9%E4%BD%93%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E6%B3%95/</guid>
      <description>keywords: UE4、Movement
作者：@玄冬Wong
1，Actor-&amp;gt;SetActorLocation
Actor-&amp;gt;SetActorLocation()  2，Velocity
ACharacter-&amp;gt;GetCharacterMovement()-&amp;gt;Velocity += FVector(5.f, 5.f, 0.f);  3，将一个Controller（PlayerController或者AIController）possess到一个Actor上，然后调用：
Controller-&amp;gt;MoveTo();  4，将一个Controller（PlayerController或者AIController）possess到一个Actor上，然后调用
GetWorld()-&amp;gt;GetNavigationSystem()-&amp;gt;SimpleMoveToLocation(Controller, DestLocation);  注意：如果使用Controller-&amp;gt;MoveTo或者使用NavigationSystem的Move函数，前提条件是你使用了Navigation组件并build了地形，否则无效。
 5，APawn-&amp;gt;AddMovementInput
APawn-&amp;gt;AddMovementInput(FVector WorldDirection, float ScaleValue = 1.0f, bool bForce = false);  其中WorldDirection是方向，ScaleValue是速率倍速，bForce表示是否忽略Controller中的IgnoreMoveInput属性值，强制移动。
6，UCharacterMovementComponent::AddImpulse
void UCharacterMovementComponent::AddImpulse( FVector Impulse, bool bVelocityChange )  AddImpulse一般用来做投掷、爆炸、击飞等物理效果。添加的是一个瞬间的力，之后就不需要每帧做处理了。
7，UCharacterMovementComponent::AddForce
void UCharacterMovementComponent::AddForce( FVector Force )  如果想让物体保持移动，需要每帧都执行AddForce()函数，也就说如果加速度是实时变化的，那么就可以用AddForce。 两者的区别可以参考：
https://forums.unrealengine.com/showthread.php?29496-Addforce-and-addimpulse
AddForce accounts for delta time and should be used for applying force over more than one frame, AddImpulse does not account for delta time and should be used for single &#39;pushes&#39;, like from an explosion or being thrown by a player.</description>
    </item>
    
    <item>
      <title>[UE4]Constructor与Runtime两种环境下创建Component并Attach的方式</title>
      <link>http://www.dawnarc.com/2016/05/ue4constructor%E4%B8%8Eruntime%E4%B8%A4%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%9B%E5%BB%BAcomponent%E5%B9%B6attach%E7%9A%84%E6%96%B9%E5%BC%8F/</link>
      <pubDate>Sun, 29 May 2016 15:47:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/05/ue4constructor%E4%B8%8Eruntime%E4%B8%A4%E7%A7%8D%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%88%9B%E5%BB%BAcomponent%E5%B9%B6attach%E7%9A%84%E6%96%B9%E5%BC%8F/</guid>
      <description>Component MyActor.h：
UShapeComponent * CollisionMesh;  Constructor中 Create &amp;amp; Attach MyActor.cpp：
CollisionMesh = CreateDefaultSubobject&amp;lt;UBoxComponent&amp;gt;(TEXT(&amp;quot;TestCollision&amp;quot;)); if(CollisionMesh) { CollisionMesh-&amp;gt;SetupAttachment(GetRootComponent()); }  Runtime中（非构造） Create &amp;amp; Attach MyActor.cpp：
CollisionMesh = NewObject&amp;lt;UBoxComponent&amp;gt;(this); if (CollisionMesh) { CollisionMesh-&amp;gt;RegisterComponent(); CollisionMesh-&amp;gt;AttachToComponent(GetRootComponent(), FAttachmentTransformRules::KeepRelativeTransform); }  Actor Runtime中Actor和Actor之间相互Attach Actor1 = GetWorld()-&amp;gt;SpawnActor&amp;lt;AMyActor&amp;gt;(AMyActor::StaticClass()); if(Actor1) { Actor1-&amp;gt;AttachToActor(Actor2, FAttachmentTransformRules::KeepRelativeTransform); }  Constructor中 Create &amp;amp; Attach 很少情况下需要在构造函数执行Actor之间的相关Attach。
ConstructorHelpers::FObjectFinder&amp;lt;UMaterial&amp;gt; DecalMaterialAsset(TEXT(&amp;quot;Material&#39;/Game/TopDownCPP/Blueprints/M_Cursor_Decal.M_Cursor_Decal&#39;&amp;quot;)); if (DecalMaterialAsset.Succeeded()) { DecalMaterialAsset.AttachToActor(MyActor, FAttachmentTransformRules::KeepRelativeTransform); }  AttachToComponent()为引擎的仅次于UObject的子类ActorComponent的函数； AttachToActor为引擎的仅次于UObject的子类Actor的函数。
 通过NewObject创建Component之后，执行Register的目的是为了触发OnComponentCreate等回调。不执行Create相关的Initial回调会导致后续的Attach失效。
 注意：Actor::AttachToActor()和Actor::AttachTo()为4.12的新版API，旧版本的工程迁移至4.12后，编译提示警告：
AActor::AttachRootComponentToActor已废弃，需要使用AttachToActor替换</description>
    </item>
    
    <item>
      <title>[UE4]C&#43;&#43;的K2 API和普通API有什么区别</title>
      <link>http://www.dawnarc.com/2016/05/ue4c--%E7%9A%84k2-api%E5%92%8C%E6%99%AE%E9%80%9Aapi%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Sun, 29 May 2016 15:08:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/05/ue4c--%E7%9A%84k2-api%E5%92%8C%E6%99%AE%E9%80%9Aapi%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</guid>
      <description>比如我们看到很多API都有一个以K2开头的API，比如 AActor::AttachRootComponentTo对应的有一个API叫
AActor::K2_AttachRootComponentTo  这些K2的和常规API有什么区别：K2是给蓝图用调换的，如果你使用C++编码，那么这些K2的开头的不需要关心。 蓝图的前身是UDK的Kismet，所以有人认为K2是Kismet 2.0的意思，即蓝图。
参考：https://answers.unrealengine.com/questions/38197/what-is-k2-functions.html</description>
    </item>
    
    <item>
      <title>[UE4]FString常用API</title>
      <link>http://www.dawnarc.com/2016/03/ue4fstring%E5%B8%B8%E7%94%A8api/</link>
      <pubDate>Tue, 01 Mar 2016 16:45:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/03/ue4fstring%E5%B8%B8%E7%94%A8api/</guid>
      <description>将int或float转换为string：
FString NewString = FString::FromInt(YourInt); FString VeryCleanString = FString::SanitizeFloat(YourFloat);  将FString转换为char*：
FString s; char *c = *s;  将string转换为int或者float：
FString TheString = &amp;quot;123.021&amp;quot;; int32 MyShinyNewInt = FCString::Atoi(*TheString); float MyShinyNewFloat = FCString::Atof(*TheString);  字符串切割：
FString a(&amp;quot;1,2,3&amp;quot;); TArray&amp;lt;FString&amp;gt; stringArray; a.ParseIntoArray(stringArray, TEXT(&amp;quot;,&amp;quot;), false);  字符串截取：
FString::Left(int count); FString::Right(int count);  字符串格式化Format：
FString Path = FString::Printf(TEXT(&amp;quot;StaticMesh&#39;/Game/Shapes/ground_shape_%d.ground_shape_%d&#39;&amp;quot;), i);  </description>
    </item>
    
    <item>
      <title>[UE4]如何播放Montage动画(C&#43;&#43;)</title>
      <link>http://www.dawnarc.com/2016/02/ue4%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEmontage%E5%8A%A8%E7%94%BBc--/</link>
      <pubDate>Thu, 18 Feb 2016 16:40:02 +0800</pubDate>
      
      <guid>http://www.dawnarc.com/2016/02/ue4%E5%A6%82%E4%BD%95%E6%92%AD%E6%94%BEmontage%E5%8A%A8%E7%94%BBc--/</guid>
      <description>假设是在Character内执行，其中MontagePtr为Montage指针：
float DeathAnimDuration = PlayAnimMontage(MontagePtr) / (GetMesh() &amp;amp;&amp;amp; GetMesh()-&amp;gt;GlobalAnimRateScale &amp;gt; 0 ? GetMesh()-&amp;gt;GlobalAnimRateScale : 1);  如果只是播放Animation Sequence，可以使用 PlayAnimation()
if (USkeletalMeshComponent *Mesh = GetMesh()) { Mesh-&amp;gt;PlayAnimation(AnimSequence, false); }  注意：PlayAnimation可以直接来播放AnimSequence，但是不能混合动作。比如当播放完攻击动作后，无法自动回到空闲状态，但是通过Montage的Slot可以完成自动切换动作。
 C++动态播放Montage（通过AnimSequence创建） http://www.dawnarc.com/2017/12/ue4c--%E5%8A%A8%E6%80%81%E5%88%9B%E5%BB%BAmontage%E5%B9%B6%E6%92%AD%E6%94%BE%E5%8A%A8%E7%94%BB/
其他参考： How can I play animations strictly from C++?
https://answers.unrealengine.com/questions/292345/how-can-i-play-animations-strictly-from-c.html</description>
    </item>
    
  </channel>
</rss>