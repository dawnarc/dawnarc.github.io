<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 玄冬Wong</title>
    <link>https://dawnarc.com/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 05 May 2019 20:52:40 +0800</lastBuildDate>
    
	<atom:link href="https://dawnarc.com/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[C&#43;&#43;]Book Guide and List</title>
      <link>https://dawnarc.com/2019/05/c-book-guide-and-list/</link>
      <pubDate>Sun, 05 May 2019 20:52:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-book-guide-and-list/</guid>
      <description>&lt;p&gt;keywords: C++ Book&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Equivalent of instanceof (object type checking at run-time)</title>
      <link>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time/</link>
      <pubDate>Sun, 05 May 2019 11:33:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time/</guid>
      <description>&lt;p&gt;keywords: C++, instanceof, typeof&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]One std vector containing template class of multiple types</title>
      <link>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</link>
      <pubDate>Mon, 15 Apr 2019 17:28:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</guid>
      <description>&lt;p&gt;keywords: vector, list, element, multiple template types&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Address source line from crash callstack using binary</title>
      <link>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</link>
      <pubDate>Wed, 02 Jan 2019 11:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</guid>
      <description>&lt;p&gt;Get the crash callstack.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]const_cast</title>
      <link>https://dawnarc.com/2018/11/c-const_cast/</link>
      <pubDate>Fri, 30 Nov 2018 14:34:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/11/c-const_cast/</guid>
      <description>&lt;p&gt;You are not allowed to &lt;code&gt;const_cast&lt;/code&gt; variables that are actually &lt;code&gt;const&lt;/code&gt;. This results in undefined behavior.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39;</title>
      <link>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</link>
      <pubDate>Sun, 16 Sep 2018 20:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</guid>
      <description>Compiling Error:
error C2664: &#39;void TestFun01(std::string &amp;)&#39;: cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39; Solution:
add const to std::string&amp;amp; which is a parameter of function, like this:
void TestFun01(const std::string&amp;amp; text) { std::cout &amp;lt;&amp;lt; text; } void TestFun02() { TestFun01(&amp;quot;abcd&amp;quot;); }  this would produce compilation error:
void TestFun01(std::string&amp;amp; text) { std::cout &amp;lt;&amp;lt; text; } void TestFun02() { TestFun01(&amp;quot;abcd&amp;quot;); }  人，越有智慧越显得孤独苦恼。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 shared_ptr 与 weak_ptr 区别</title>
      <link>https://dawnarc.com/2018/07/c-c-11-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 06 Jul 2018 14:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/c-c-11-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</guid>
      <description>shared_ptr 语法：
#include &amp;lt;memory&amp;gt; shared_ptr&amp;lt;A&amp;gt; x(new A);  shared_ptr 相当于 对象引用计数器。每当对 shared_ptr 赋值操作一次，则其引用对象的计数+1。当某对象的引用计数为0时，则该对象自动销毁。
weak_ptr 语法：
#include &amp;lt;memory&amp;gt; weak_ptr&amp;lt;A&amp;gt; x(new A);  weak_ptr 典型应用是缓存：例如我们在缓存中存放了一个 raw pointer 来指向某个对象，如果这个对象在其他地方被销毁了，那么缓存中的这个 raw pointer 指向的对象不存在。如果我们希望某个对象在其他地方被销毁时，缓存中指向该对象的指针也马上被置为 null，那么就可以使用 weak_ptr。
参考自：
shared_ptr and weak_ptr differences
https://stackoverflow.com/questions/4984381/shared-ptr-and-weak-ptr-differences
When is std::weak_ptr useful?
https://stackoverflow.com/questions/12030650/when-is-stdweak-ptr-useful
我希望我的文字，是一场一场的梦，是一阵一阵的风，是一片一片的月光。那些生活于尘土中的人们，那些在四季轮回中迷失了方向的人们，那些在大地的收货和欠收中痛苦和欣喜的人们，他们会有一个朝上仰望的这样一颗心灵。如果文学还能做什么，那么，文学需要承载大地上所有的苦难和沉重，让人们抬起头来，朝着云端去望，朝着树叶去望。这就是文学唯一能给我们的一点安慰。----刘亮程</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]non-static member function as callback function and achieve inheritance</title>
      <link>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</link>
      <pubDate>Sat, 30 Jun 2018 17:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</guid>
      <description>keywords：C++ 非静态成员函数作为回调函数并实现继承多态
Base.hpp
#pragma once class Base { public: virtual void TestFun1(int Param) {} virtual void TestFun2(int Param) {} };  Child.hpp
#pragma once #include &amp;lt;iostream&amp;gt; #include &amp;quot;Base.hpp&amp;quot; class Child : public Base { public: void TestFun1(int Param) override { printf(&amp;quot;Fun1 : %d\n&amp;quot;, Param); } void TestFun2(int Param) override { printf(&amp;quot;Fun2 : %d\n&amp;quot;, Param); } };  EventManager.h
// Fill out your copyright notice in the Description page of Project Settings.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to erase an element from std vector by index</title>
      <link>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</link>
      <pubDate>Fri, 29 Jun 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</guid>
      <description>keywords：C++ 用索引删除 std::vector 中的数组元素
To delete a single element, you could do:
std::vector&amp;lt;int&amp;gt; vec; vec.push_back(6); vec.push_back(-17); vec.push_back(12); // Deletes the second element (vec[1]) vec.erase(vec.begin() + 1);  Or, to delete more than one element at once:
// Deletes the second through third elements (vec[1], vec[2]) vec.erase(vec.begin() + 1, vec.begin() + 3);  参考自：How do I erase an element from std::vector&amp;lt;&amp;gt; by index?
https://stackoverflow.com/questions/875103/how-do-i-erase-an-element-from-stdvector-by-index
无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归宿。---路遥《平凡的世界》</description>
    </item>
    
    <item>
      <title>[Dlang]C&#43;&#43;相对D的优点</title>
      <link>https://dawnarc.com/2018/06/dlangc-%E7%9B%B8%E5%AF%B9d%E7%9A%84%E4%BC%98%E7%82%B9/</link>
      <pubDate>Sat, 23 Jun 2018 17:58:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/dlangc-%E7%9B%B8%E5%AF%B9d%E7%9A%84%E4%BC%98%E7%82%B9/</guid>
      <description>原文：What does C++ do better than D?
https://softwareengineering.stackexchange.com/questions/97207/what-does-c-do-better-than-d
Most of the things C++ &amp;ldquo;does&amp;rdquo; better than D are meta things:
C++ has better compilers, better tools, more mature libraries, more bindings, more experts, more tutorials etc. Basically it has more and better of all the external things that you would expect from a more mature language. This is inarguable.
As for the language itself, there are a few things that C++ does better than D in my opinion.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to add constructors or destructors to an unnamed class(为匿名类添加构造函数与析构函数)</title>
      <link>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 06 Jun 2018 17:44:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：匿名类，匿名结构体、构造函数、析构函数、Lambda
为匿名类添加构造函数与析构函数，有两种方式：
 C++98中在匿名类内部加一个命名类 C++11 Lambda语法  C++98 C++98中，可以在匿名类内部放一个命名类(named class )，然后再为命名类添加构造和析构函数，当匿名类构造或析构时，就会去调用命名类的构造函数和析构函数。
#include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; int main() { struct { struct S { double a; int b; S() : a(sqrt(4)), b(42) { std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; } ~S() { std::cout &amp;lt;&amp;lt; &amp;quot;destructed&amp;quot; &amp;lt;&amp;lt; std::endl; } } s; } instance1, instance2; std::cout &amp;lt;&amp;lt; &amp;quot;body&amp;quot; &amp;lt;&amp;lt; std::endl; }  C++11 Lambda #include &amp;lt;iostream&amp;gt; #include &amp;lt;cmath&amp;gt; int main() { struct { double a { sqrt(4) }; int b { []{ std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; return 42; }() }; } instance1, instance2; }  参考 How to add constructors/destructors to an unnamed class?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]正确使用STL-MAP中Erase函数</title>
      <link>https://dawnarc.com/2018/05/c-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8stl-map%E4%B8%ADerase%E5%87%BD%E6%95%B0/</link>
      <pubDate>Fri, 11 May 2018 01:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/05/c-%E6%AD%A3%E7%A1%AE%E4%BD%BF%E7%94%A8stl-map%E4%B8%ADerase%E5%87%BD%E6%95%B0/</guid>
      <description>原文：http://www.cnblogs.com/graphics/archive/2010/07/05/1771110.html
#include &amp;lt;iostream&amp;gt; #include &amp;lt;map&amp;gt; #include &amp;lt;string&amp;gt; using namespace std ; int main(void) { map&amp;lt;int, string&amp;gt; m ; m.insert(pair&amp;lt;int, string&amp;gt;(1, &amp;quot;abc&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(2, &amp;quot;def&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(3, &amp;quot;def&amp;quot;)) ; m.insert(pair&amp;lt;int, string&amp;gt;(4, &amp;quot;ghi&amp;quot;)) ; map&amp;lt;int, string&amp;gt;::iterator itor ; // 错误的写法 for (itor = m.begin(); itor != m.end(); ++itor) { if (itor-&amp;gt;second == &amp;quot;def&amp;quot;) { m.erase(itor) ; // map是关联式容器，调用erase后，当前迭代器已经失效 } } // 正确的写法 for (itor = m.begin(); itor != m.end();) { if (itor-&amp;gt;second == &amp;quot;def&amp;quot;) { m.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]读写二进制文件和文本文件</title>
      <link>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 20 Apr 2018 17:45:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</guid>
      <description>ifstream,ofstream读写二进制文件 #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(int argc, char** argv) { int a[5] = {1,2,3,4,5}; int b[5]; ofstream ouF; ouF.open(&amp;quot;./me.dat&amp;quot;, std::ofstream::binary); ouF.write(reinterpret_cast&amp;lt;const char*&amp;gt;(a), sizeof(int)*5); ouF.close(); ifstream inF; inF.open(&amp;quot;./me.dat&amp;quot;, std::ifstream::binary); inF.read(reinterpret_cast&amp;lt;char*&amp;gt;(b), sizeof(int)*5); inF.close(); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; endl; } return 0; }  参考自：https://blog.csdn.net/bendanban/article/details/30039193
C模式读写二进制文件 //采用C模式写二进制文件 void DataWrite_CMode() { //准备数据 double pos[200]; for(int i = 0; i &amp;lt; 200; i ++ ) pos[i] = i ; //写出数据 FILE *fid; fid = fopen(&amp;quot;binary.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]两个连续感叹号(双感叹号)的意义</title>
      <link>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</link>
      <pubDate>Sat, 03 Feb 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
      <description>网上看到有些代码在判断指针是否为空时，写两个感叹号：
void Test(A* Ptr) { bool b = !!Ptr; ... }  如果是C++，极其不推荐这样写，这是从JavaScript，TypeScript转C++的程序员，在用JS的语法写C++代码，JS必须这样，但是C++就不必了。
Defining double exclamation?
https://stackoverflow.com/questions/11374810/defining-double-exclamation
时间是一只藏在黑暗中的温柔的手，在你一出神一恍惚之间，物走星移。----龙应台《目送》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 template alias和using(模板的模板)</title>
      <link>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 29 Sep 2017 18:47:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</guid>
      <description>keywords：alias template、模板别名、模板的模板
如果模版的type(T)不是具体类型，也是一个模板，C++11之前的语法不支持，现在C++11提供了新的语法支持这种场景：using identifier attr(optional) = type-id
示例：
template &amp;lt;template &amp;lt;typename&amp;gt; class&amp;gt; struct X { X() { std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot;; } }; template &amp;lt;typename&amp;gt; struct Y { }; template &amp;lt;typename T&amp;gt; using Z = Y&amp;lt;T&amp;gt;; template &amp;lt;&amp;gt; struct X&amp;lt;Y&amp;gt; { X() { std::cout &amp;lt;&amp;lt; &amp;quot;2&amp;quot;; } }; int main(int argc, char* argv[]) { X&amp;lt;Y&amp;gt; x1; X&amp;lt;Z&amp;gt; x2; }  运行结果：
21  Type alias, alias template (since C++11)
http://en.cppreference.com/w/cpp/language/type_alias
尺之木必有节目，寸之玉必有瑕瓋。---《吕氏春秋》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]基础备忘：显式调用构造</title>
      <link>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 24 Aug 2017 16:51:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</guid>
      <description>最近两年一直在使用UE4 Stylized C++，标准C++的一些基础都快忘了。。。
示例代码：
#include &amp;lt;iostream&amp;gt; class CA { public: //两种初始化成员变量的方法 CA() : ia_(11) { fa_ = 0.f; } CA(int val) : ia_(val) { fa_ = 0.f; } //要想让子类能够访问，修饰符不可为private protected: int ia_; private: float fa_; }; class CB : public CA { public: //显示调用父类的有参构造函数 CB() : CA(33), ib_(22) { } int ib() { return ib_; } int ia() { return ia_; } private: int ib_; }; int main(int argc, char* argv[]) { CB b; std::cout &amp;lt;&amp;lt; b.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]可变参数_VA_ARGS__ </title>
      <link>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</link>
      <pubDate>Wed, 19 Apr 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</guid>
      <description>参考自：https://stackoverflow.com/questions/2124339/c-preprocessor-va-args-number-of-arguments
#include &amp;lt;stdio.h&amp;gt; #include &amp;lt;string.h&amp;gt; #include &amp;lt;stdarg.h&amp;gt; #define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int)) #define SUM(...) (sum(NUMARGS(__VA_ARGS__), __VA_ARGS__)) void sum(int numargs, ...); int main(int argc, char *argv[]) { SUM(1); SUM(1, 2); SUM(1, 2, 3); SUM(1, 2, 3, 4); return 1; } void sum(int numargs, ...) { int total = 0; va_list ap; printf(&amp;quot;sum() called with %d params:&amp;quot;, numargs); va_start(ap, numargs); while (numargs--) total += va_arg(ap, int); va_end(ap); printf(&amp;quot; %d\n&amp;quot;, total); return; }  晚食以当肉，安步以当车，无罪以当贵，清静贞正以当虞。---《战国策》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]带参的回调函数编写技巧(模板函数)</title>
      <link>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Feb 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>比如要设置一连串的回调函数来响应键盘的0到9数字键，注册回调函数时无法把数字0到9作为函数参数一起注册，那么有没其他办法？答案肯定是有！具体方式如下：
1，先定义好需要回调的函数，假如：
void TestCallback(int index);  2，再定义一个模板函数将上面的函数封装：
template&amp;lt;int index&amp;gt; void TestCallback() { TestCallback(index); }  3，最后在注册回调时，将数字作为模板类型来注册：
CallbackMaster-&amp;gt;Bind(&amp;amp;MyClass::TestCallback&amp;lt;9&amp;gt;);  不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。——《荀子》</description>
    </item>
    
  </channel>
</rss>