<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>C&#43;&#43; on 玄冬Wong</title>
    <link>https://dawnarc.com/tags/c&#43;&#43;/</link>
    <description>Recent content in C&#43;&#43; on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 22 Dec 2020 18:10:03 +0800</lastBuildDate><atom:link href="https://dawnarc.com/tags/c++/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[C&#43;&#43;]Building Error Notes - Windows</title>
      <link>https://dawnarc.com/2020/12/c-building-error-notes-windows/</link>
      <pubDate>Tue, 22 Dec 2020 18:10:03 +0800</pubDate>
      
      <guid>https://dawnarc.com/2020/12/c-building-error-notes-windows/</guid>
      <description>&lt;p&gt;keywords: C++, std_Binderstd_Unforced, sockaddr, int __cdecl invoke_main(void)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Foreach Operator Overload</title>
      <link>https://dawnarc.com/2020/10/c-foreach-operator-overload/</link>
      <pubDate>Wed, 21 Oct 2020 21:10:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2020/10/c-foreach-operator-overload/</guid>
      <description>&lt;p&gt;keywords: C++, Foreach Operator Overload&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Advanced Features Notes</title>
      <link>https://dawnarc.com/2020/07/c-advanced-features-notes/</link>
      <pubDate>Sun, 12 Jul 2020 22:51:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2020/07/c-advanced-features-notes/</guid>
      <description>&lt;p&gt;keywords: C++, Advanced Features Notes, Tutorials&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Memory Ordering &amp; Memory Barrier Notes</title>
      <link>https://dawnarc.com/2020/06/c-memory-ordering-memory-barrier-notes/</link>
      <pubDate>Thu, 25 Jun 2020 16:04:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2020/06/c-memory-ordering-memory-barrier-notes/</guid>
      <description>&lt;p&gt;keywords: C++, Memory Ordering Notes&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Template Parameters Checking</title>
      <link>https://dawnarc.com/2019/12/c-template-parameters-checking/</link>
      <pubDate>Sun, 15 Dec 2019 00:31:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/12/c-template-parameters-checking/</guid>
      <description>&lt;p&gt;keywords: C++ Template Parameters Checking&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to use a struct as key in a std map</title>
      <link>https://dawnarc.com/2019/09/c-how-to-use-a-struct-as-key-in-a-std-map/</link>
      <pubDate>Mon, 09 Sep 2019 16:38:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/09/c-how-to-use-a-struct-as-key-in-a-std-map/</guid>
      <description>&lt;p&gt;keywords: C++, std map, struct as key&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Byte Alignment (pack pragma)</title>
      <link>https://dawnarc.com/2019/09/c-byte-alignment-pack-pragma/</link>
      <pubDate>Fri, 06 Sep 2019 15:36:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/09/c-byte-alignment-pack-pragma/</guid>
      <description>&lt;p&gt;keywords: C++, Byte Alignment, pack pragma&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Execution Order of Constructor and Deconstrutor in Inheritance</title>
      <link>https://dawnarc.com/2019/07/c-execution-order-of-constructor-and-deconstrutor-in-inheritance/</link>
      <pubDate>Thu, 25 Jul 2019 21:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-execution-order-of-constructor-and-deconstrutor-in-inheritance/</guid>
      <description>&lt;p&gt;keywords: C++, Constructor, Deconstrutor&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How Are Virtual Functions Implemented At a Deep Level</title>
      <link>https://dawnarc.com/2019/07/c-how-are-virtual-functions-implemented-at-a-deep-level/</link>
      <pubDate>Thu, 25 Jul 2019 18:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-how-are-virtual-functions-implemented-at-a-deep-level/</guid>
      <description>&lt;p&gt;keywords: Virtual Functions, VTables&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Pure LLVM(Clang) Compilation Libraries</title>
      <link>https://dawnarc.com/2019/07/c-pure-llvmclang-compilation-libraries/</link>
      <pubDate>Sun, 07 Jul 2019 14:48:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-pure-llvmclang-compilation-libraries/</guid>
      <description>&lt;p&gt;keywords: LLVM Clang Compilation Library&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Clang Compilation Error - expected unqualified-id</title>
      <link>https://dawnarc.com/2019/07/c-clang-compilation-error-expected-unqualified-id/</link>
      <pubDate>Sat, 06 Jul 2019 21:57:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-clang-compilation-error-expected-unqualified-id/</guid>
      <description>&lt;p&gt;keywords: Clang Compilation Error&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Tricks on Building</title>
      <link>https://dawnarc.com/2019/07/c-tricks-on-building/</link>
      <pubDate>Thu, 04 Jul 2019 21:27:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-tricks-on-building/</guid>
      <description>&lt;p&gt;keywords: View Content of Static Library(.lib) and Shared Library(.dll)&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]error - templates must have C&#43;&#43; linkage</title>
      <link>https://dawnarc.com/2019/07/c-error-templates-must-have-c-linkage/</link>
      <pubDate>Tue, 02 Jul 2019 15:37:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/07/c-error-templates-must-have-c-linkage/</guid>
      <description>&lt;p&gt;keywords: C++ linkage&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Book Guide and List</title>
      <link>https://dawnarc.com/2019/05/c-book-guide-and-list/</link>
      <pubDate>Sun, 05 May 2019 20:52:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-book-guide-and-list/</guid>
      <description>&lt;p&gt;keywords: C++ Book&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Equivalent of instanceof (object type checking at run-time)- dynamic_cast</title>
      <link>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time-dynamic_cast/</link>
      <pubDate>Sun, 05 May 2019 11:33:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/05/c-equivalent-of-instanceof-object-type-checking-at-run-time-dynamic_cast/</guid>
      <description>&lt;p&gt;keywords: C++, instanceof, typeof&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]One std vector containing template class of multiple types</title>
      <link>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</link>
      <pubDate>Mon, 15 Apr 2019 17:28:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/04/c-one-std-vector-containing-template-class-of-multiple-types/</guid>
      <description>&lt;p&gt;keywords: vector, list, element, multiple template types, different types&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]STD Move &amp; Forward Notes</title>
      <link>https://dawnarc.com/2019/02/c-std-move-forward-notes/</link>
      <pubDate>Fri, 01 Feb 2019 14:05:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/02/c-std-move-forward-notes/</guid>
      <description>&lt;p&gt;keywords: VS2019, Code Analysis, Code Checking, std::move&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Address source line from crash callstack using binary</title>
      <link>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</link>
      <pubDate>Wed, 02 Jan 2019 11:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2019/01/c-address-source-line-from-crash-callstack-using-binary/</guid>
      <description>&lt;p&gt;keywords: Windows Debugging Tools, Whitout PDB file, Crash, Dump file, Linux Core Dump, GDB debug&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]const_cast</title>
      <link>https://dawnarc.com/2018/11/c-const_cast/</link>
      <pubDate>Fri, 30 Nov 2018 14:34:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/11/c-const_cast/</guid>
      <description>&lt;p&gt;You are not allowed to &lt;code&gt;const_cast&lt;/code&gt; variables that are actually &lt;code&gt;const&lt;/code&gt;. This results in undefined behavior.&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39;</title>
      <link>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</link>
      <pubDate>Sun, 16 Sep 2018 20:26:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/09/c-cannot-convert-argument-1-from-const-char-5-to-stdstring/</guid>
      <description>Compiling Error:
error C2664: &#39;void TestFun01(std::string &amp;)&#39;: cannot convert argument 1 from &#39;const char [5]&#39; to &#39;std::string &amp;&#39;Solution:
add const to std::string&amp;amp; which is a parameter of function, like this:
void TestFun01(const std::string&amp;amp; text){std::cout &amp;lt;&amp;lt; text;}void TestFun02(){TestFun01(&amp;quot;abcd&amp;quot;);}this would produce compilation error:
void TestFun01(std::string&amp;amp; text){std::cout &amp;lt;&amp;lt; text;}void TestFun02(){TestFun01(&amp;quot;abcd&amp;quot;);}人，越有智慧越显得孤独苦恼。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]shared_ptr 与 weak_ptr 区别</title>
      <link>https://dawnarc.com/2018/07/c-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</link>
      <pubDate>Fri, 06 Jul 2018 14:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/c-shared_ptr-%E4%B8%8E-weak_ptr-%E5%8C%BA%E5%88%AB/</guid>
      <description>&lt;p&gt;&lt;code&gt;shared_ptr&lt;/code&gt;与&lt;code&gt;weak_ptr&lt;/code&gt;由C++11引入。&lt;/p&gt;</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]non-static member function as callback function and achieve inheritance</title>
      <link>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</link>
      <pubDate>Sat, 30 Jun 2018 17:19:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-non-static-member-function-as-callback-function-and-achieve-inheritance/</guid>
      <description>keywords：C++ 非静态成员函数作为回调函数并实现继承多态
Base.hpp
#pragma onceclass Base{public:virtual void TestFun1(int Param) {}virtual void TestFun2(int Param) {}};Child.hpp
#pragma once#include &amp;lt;iostream&amp;gt;#include &amp;quot;Base.hpp&amp;quot;class Child : public Base{public:void TestFun1(int Param) override{printf(&amp;quot;Fun1 : %d\n&amp;quot;, Param);}void TestFun2(int Param) override{printf(&amp;quot;Fun2 : %d\n&amp;quot;, Param);}};EventManager.h
// Fill out your copyright notice in the Description page of Project Settings.#pragma once#include &amp;lt;map&amp;gt;#include &amp;lt;vector&amp;gt;#include &amp;quot;Base.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to erase an element from std vector by index</title>
      <link>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</link>
      <pubDate>Fri, 29 Jun 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-erase-an-element-from-std-vector-by-index/</guid>
      <description>keywords：C++ 用索引删除 std::vector 中的数组元素
To delete a single element, you could do:
std::vector&amp;lt;int&amp;gt; vec;vec.push_back(6);vec.push_back(-17);vec.push_back(12);// Deletes the second element (vec[1])vec.erase(vec.begin() + 1);Or, to delete more than one element at once:
// Deletes the second through third elements (vec[1], vec[2])vec.erase(vec.begin() + 1, vec.begin() + 3);参考自：How do I erase an element from std::vector&amp;lt;&amp;gt; by index?
https://stackoverflow.com/questions/875103/how-do-i-erase-an-element-from-stdvector-by-index
无论精神多么独立的人，感情却总是在寻找一种依附，寻找一种归宿。---路遥《平凡的世界》</description>
    </item>
    
    <item>
      <title>[Dlang]C&#43;&#43;相对D的优点</title>
      <link>https://dawnarc.com/2018/06/dlangc-%E7%9B%B8%E5%AF%B9d%E7%9A%84%E4%BC%98%E7%82%B9/</link>
      <pubDate>Sat, 23 Jun 2018 17:58:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/dlangc-%E7%9B%B8%E5%AF%B9d%E7%9A%84%E4%BC%98%E7%82%B9/</guid>
      <description>原文：What does C++ do better than D?
https://softwareengineering.stackexchange.com/questions/97207/what-does-c-do-better-than-d
Most of the things C++ &amp;ldquo;does&amp;rdquo; better than D are meta things:
C++ has better compilers, better tools, more mature libraries, more bindings, more experts, more tutorials etc. Basically it has more and better of all the external things that you would expect from a more mature language. This is inarguable.
As for the language itself, there are a few things that C++ does better than D in my opinion.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to add constructors or destructors to an unnamed class(为匿名类添加构造函数与析构函数)</title>
      <link>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</link>
      <pubDate>Wed, 06 Jun 2018 17:44:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/06/c-how-to-add-constructors-or-destructors-to-an-unnamed-class%E4%B8%BA%E5%8C%BF%E5%90%8D%E7%B1%BB%E6%B7%BB%E5%8A%A0%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0/</guid>
      <description>keywords：匿名类，匿名结构体、构造函数、析构函数、Lambda
为匿名类添加构造函数与析构函数，有两种方式：
C++98中在匿名类内部加一个命名类 C++11 Lambda语法 C++98 C++98中，可以在匿名类内部放一个命名类(named class )，然后再为命名类添加构造和析构函数，当匿名类构造或析构时，就会去调用命名类的构造函数和析构函数。
#include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;int main() {struct {struct S {double a;int b;S() : a(sqrt(4)), b(42) { std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl; }~S() { std::cout &amp;lt;&amp;lt; &amp;quot;destructed&amp;quot; &amp;lt;&amp;lt; std::endl; }} s;} instance1, instance2;std::cout &amp;lt;&amp;lt; &amp;quot;body&amp;quot; &amp;lt;&amp;lt; std::endl;}C++11 Lambda #include &amp;lt;iostream&amp;gt;#include &amp;lt;cmath&amp;gt;int main() {struct {double a { sqrt(4) };int b { []{std::cout &amp;lt;&amp;lt; &amp;quot;constructed&amp;quot; &amp;lt;&amp;lt; std::endl;return 42; }()};} instance1, instance2;}参考 How to add constructors/destructors to an unnamed class?</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]How to use erase of std map correctly</title>
      <link>https://dawnarc.com/2018/05/c-how-to-use-erase-of-std-map-correctly/</link>
      <pubDate>Fri, 11 May 2018 01:11:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/05/c-how-to-use-erase-of-std-map-correctly/</guid>
      <description>Origin Text: http://www.cnblogs.com/graphics/archive/2010/07/05/1771110.html
#include &amp;lt;iostream&amp;gt;#include &amp;lt;map&amp;gt;#include &amp;lt;string&amp;gt;using namespace std ;int main(void) { map&amp;lt;int, string&amp;gt; m ;m.insert(pair&amp;lt;int, string&amp;gt;(1, &amp;quot;abc&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(2, &amp;quot;def&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(3, &amp;quot;def&amp;quot;)) ;m.insert(pair&amp;lt;int, string&amp;gt;(4, &amp;quot;ghi&amp;quot;)) ;map&amp;lt;int, string&amp;gt;::iterator itor ;// Print mmap&amp;lt;int, string&amp;gt;::const_iterator citor ;for (citor = m.begin(); citor != m.end(); ++citor){cout &amp;lt;&amp;lt; citor-&amp;gt;first &amp;lt;&amp;lt; &amp;quot;:&amp;quot; &amp;lt;&amp;lt; citor-&amp;gt;second &amp;lt;&amp;lt; endl ;}return 0 ; } Wrong way 1st: for (itor = m.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]读写二进制文件和文本文件</title>
      <link>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</link>
      <pubDate>Fri, 20 Apr 2018 17:45:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/c-%E8%AF%BB%E5%86%99%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%96%87%E4%BB%B6%E5%92%8C%E6%96%87%E6%9C%AC%E6%96%87%E4%BB%B6/</guid>
      <description>ifstream,ofstream读写二进制文件 #include &amp;lt;iostream&amp;gt; #include &amp;lt;fstream&amp;gt; using namespace std; int main(int argc, char** argv) { int a[5] = {1,2,3,4,5}; int b[5]; ofstream ouF; ouF.open(&amp;quot;./me.dat&amp;quot;, std::ofstream::binary); ouF.write(reinterpret_cast&amp;lt;const char*&amp;gt;(a), sizeof(int)*5); ouF.close(); ifstream inF; inF.open(&amp;quot;./me.dat&amp;quot;, std::ifstream::binary); inF.read(reinterpret_cast&amp;lt;char*&amp;gt;(b), sizeof(int)*5); inF.close(); for (int i = 0; i &amp;lt; 5; i++) { cout &amp;lt;&amp;lt; b[i] &amp;lt;&amp;lt; endl; } return 0; } 参考：
https://blog.csdn.net/bendanban/article/details/30039193
获取文件的大小：
ifstream inF;inF.open(&amp;quot;C:/test.jpg&amp;quot;, ios::binary | ios::ate);long size = inF.tellg();当使用ios::binary | ios::ate之后，inF.read(reinterpret_cast&amp;lt;char*&amp;gt;(b), sizeof(int)*5);就会失效。</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]两个连续感叹号(双感叹号)的意义</title>
      <link>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</link>
      <pubDate>Sat, 03 Feb 2018 21:39:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/02/c-%E4%B8%A4%E4%B8%AA%E8%BF%9E%E7%BB%AD%E6%84%9F%E5%8F%B9%E5%8F%B7%E5%8F%8C%E6%84%9F%E5%8F%B9%E5%8F%B7%E7%9A%84%E6%84%8F%E4%B9%89/</guid>
      <description>网上看到有些代码在判断指针是否为空时，写两个感叹号：
void Test(A* Ptr){bool b = !!Ptr;...}可能原因有两个：
从JavaScript、TypeScript转C++的程序员，在用JS的语法写C++代码，JS必须这样，但是C++中非必要； GCC提供了某些编译器参数（比如__builtin_expect），这些语法要求：对于指针类型的参数，转换为bool类型时，必须添加两个感叹号； Defining double exclamation?
https://stackoverflow.com/questions/11374810/defining-double-exclamation
__builtin_expect 说明
https://www.jianshu.com/p/2684613a300f
时间是一只藏在黑暗中的温柔的手，在你一出神一恍惚之间，物走星移。----龙应台《目送》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]C&#43;&#43;11 template alias和using(模板的模板)</title>
      <link>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</link>
      <pubDate>Fri, 29 Sep 2017 18:47:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/09/c-c-11-template-alias%E5%92%8Cusing%E6%A8%A1%E6%9D%BF%E7%9A%84%E6%A8%A1%E6%9D%BF/</guid>
      <description>keywords：alias template、模板别名、模板的模板
如果模版的type(T)不是具体类型，也是一个模板，C++11之前的语法不支持，现在C++11提供了新的语法支持这种场景：using identifier attr(optional) = type-id
示例：
template &amp;lt;template &amp;lt;typename&amp;gt; class&amp;gt;struct X{X(){std::cout &amp;lt;&amp;lt; &amp;quot;1&amp;quot;;}};template &amp;lt;typename&amp;gt;struct Y{};template &amp;lt;typename T&amp;gt;using Z = Y&amp;lt;T&amp;gt;;template &amp;lt;&amp;gt;struct X&amp;lt;Y&amp;gt;{X(){std::cout &amp;lt;&amp;lt; &amp;quot;2&amp;quot;;}};int main(int argc, char* argv[]){X&amp;lt;Y&amp;gt; x1;X&amp;lt;Z&amp;gt; x2;}运行结果：
21Type alias, alias template (since C++11)
http://en.cppreference.com/w/cpp/language/type_alias
尺之木必有节目，寸之玉必有瑕瓋。---《吕氏春秋》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]基础备忘：显式调用构造</title>
      <link>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</link>
      <pubDate>Thu, 24 Aug 2017 16:51:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/08/c-%E5%9F%BA%E7%A1%80%E5%A4%87%E5%BF%98%E6%98%BE%E5%BC%8F%E8%B0%83%E7%94%A8%E6%9E%84%E9%80%A0/</guid>
      <description>最近两年一直在使用UE4 Stylized C++，标准C++的一些基础都快忘了。。。
示例代码：
#include &amp;lt;iostream&amp;gt;class CA{public://两种初始化成员变量的方法CA() : ia_(11){fa_ = 0.f;}CA(int val) : ia_(val){fa_ = 0.f;}//要想让子类能够访问，修饰符不可为privateprotected:int ia_;private:float fa_;};class CB : public CA{public://显示调用父类的有参构造函数CB() : CA(33), ib_(22){}int ib(){return ib_;}int ia(){return ia_;}private:int ib_;};int main(int argc, char* argv[]){CB b;std::cout &amp;lt;&amp;lt; b.</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]可变参数_VA_ARGS__ </title>
      <link>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</link>
      <pubDate>Wed, 19 Apr 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/04/c-%E5%8F%AF%E5%8F%98%E5%8F%82%E6%95%B0_va_args__/</guid>
      <description>参考自：https://stackoverflow.com/questions/2124339/c-preprocessor-va-args-number-of-arguments
#include &amp;lt;stdio.h&amp;gt;#include &amp;lt;string.h&amp;gt;#include &amp;lt;stdarg.h&amp;gt;#define NUMARGS(...) (sizeof((int[]){__VA_ARGS__})/sizeof(int))#define SUM(...) (sum(NUMARGS(__VA_ARGS__), __VA_ARGS__))void sum(int numargs, ...);int main(int argc, char *argv[]) {SUM(1);SUM(1, 2);SUM(1, 2, 3);SUM(1, 2, 3, 4);return 1;}void sum(int numargs, ...) {int total = 0;va_list ap;printf(&amp;quot;sum() called with %d params:&amp;quot;, numargs);va_start(ap, numargs);while (numargs--)total += va_arg(ap, int);va_end(ap);printf(&amp;quot; %d\n&amp;quot;, total);return;}晚食以当肉，安步以当车，无罪以当贵，清静贞正以当虞。---《战国策》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]带参的回调函数编写技巧(模板函数)</title>
      <link>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</link>
      <pubDate>Tue, 28 Feb 2017 16:17:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/c-%E5%B8%A6%E5%8F%82%E7%9A%84%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%BC%96%E5%86%99%E6%8A%80%E5%B7%A7%E6%A8%A1%E6%9D%BF%E5%87%BD%E6%95%B0/</guid>
      <description>比如要设置一连串的回调函数来响应键盘的0到9数字键，注册回调函数时无法把数字0到9作为函数参数一起注册，那么有没其他办法？答案肯定是有！具体方式如下：
1，先定义好需要回调的函数，假如：
void TestCallback(int index);2，再定义一个模板函数将上面的函数封装：
template&amp;lt;int index&amp;gt;void TestCallback(){TestCallback(index);}3，最后在注册回调时，将数字作为模板类型来注册：
CallbackMaster-&amp;gt;Bind(&amp;amp;MyClass::TestCallback&amp;lt;9&amp;gt;);不积跬步，无以至千里；不积小流，无以成江海。骐骥一跃，不能十步；驽马十驾，功在不舍。锲而舍之，朽木不折；锲而不舍，金石可镂。——《荀子》</description>
    </item>
    
    <item>
      <title>[C&#43;&#43;]Memory Address Issues and Memory Leak Detecter</title>
      <link>https://dawnarc.com/2016/05/c-memory-address-issues-and-memory-leak-detecter/</link>
      <pubDate>Sat, 28 May 2016 21:42:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/05/c-memory-address-issues-and-memory-leak-detecter/</guid>
      <description>&lt;p&gt;keywords: C++, Memory Address Issues, memory leak, memory overflow, MSVC, 内存泄漏检测, 内存溢出检测, 数组越界&lt;/p&gt;</description>
    </item>
    
  </channel>
</rss>
