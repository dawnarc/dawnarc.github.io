<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Math on 玄冬Wong</title>
    <link>https://dawnarc.com/tags/math/</link>
    <description>Recent content in Math on 玄冬Wong</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 07 Oct 2018 21:30:02 +0800</lastBuildDate>
    
	<atom:link href="https://dawnarc.com/tags/math/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>[Math]Arithmetic Formula Collections</title>
      <link>https://dawnarc.com/2018/10/matharithmetic-formula-collections/</link>
      <pubDate>Sun, 07 Oct 2018 21:30:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/10/matharithmetic-formula-collections/</guid>
      <description>Calcuate distance from foot of perpendicular to line
https://math.stackexchange.com/questions/33868/foot-of-perpendicular-to-line</description>
    </item>
    
    <item>
      <title>[Math]转载：已知三点求平面方程、平面法向量和点到平面的距离</title>
      <link>https://dawnarc.com/2018/10/math%E8%BD%AC%E8%BD%BD%E5%B7%B2%E7%9F%A5%E4%B8%89%E7%82%B9%E6%B1%82%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E5%B9%B3%E9%9D%A2%E6%B3%95%E5%90%91%E9%87%8F%E5%92%8C%E7%82%B9%E5%88%B0%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/</link>
      <pubDate>Sun, 07 Oct 2018 17:13:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/10/math%E8%BD%AC%E8%BD%BD%E5%B7%B2%E7%9F%A5%E4%B8%89%E7%82%B9%E6%B1%82%E5%B9%B3%E9%9D%A2%E6%96%B9%E7%A8%8B%E5%B9%B3%E9%9D%A2%E6%B3%95%E5%90%91%E9%87%8F%E5%92%8C%E7%82%B9%E5%88%B0%E5%B9%B3%E9%9D%A2%E7%9A%84%E8%B7%9D%E7%A6%BB/</guid>
      <description>原文：https://blog.csdn.net/zhouschina/article/details/8784908
已知三点p1（x1,y1,z1），p2(x2,y2,z2)，p3(x3,y3,z3)，要求确定的平面方程。
关键在于求出平面的一个法向量，为此做向量p1p2（x2-x1,y2-y1,z2-z1), p1p3(x3-x1,y3-y1,z3-z1),平面法线和这两个向量垂直，因此法向量n：   平面方程：
a * (x - x1) + b * (y - y1) + c * (z - z1) = 0; d = -a * x1 - b * y1 - c * z1;  平面方程2:
a * x + b * y + c * z + d=0;  代码：
//已知3点坐标，求平面ax+by+cz+d=0; void get_panel(Point p1, Point p2, Point p3, double &amp;amp;a, double &amp;amp;b, double &amp;amp;c, double &amp;amp;d) { a = ( (p2.</description>
    </item>
    
    <item>
      <title>[Math]空间点到直线垂足坐标的解算方法</title>
      <link>https://dawnarc.com/2018/10/math%E7%A9%BA%E9%97%B4%E7%82%B9%E5%88%B0%E7%9B%B4%E7%BA%BF%E5%9E%82%E8%B6%B3%E5%9D%90%E6%A0%87%E7%9A%84%E8%A7%A3%E7%AE%97%E6%96%B9%E6%B3%95/</link>
      <pubDate>Fri, 05 Oct 2018 16:58:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/10/math%E7%A9%BA%E9%97%B4%E7%82%B9%E5%88%B0%E7%9B%B4%E7%BA%BF%E5%9E%82%E8%B6%B3%E5%9D%90%E6%A0%87%E7%9A%84%E8%A7%A3%E7%AE%97%E6%96%B9%E6%B3%95/</guid>
      <description>算法1 原文：https://blog.csdn.net/zhouschina/article/details/14647587
假设空间某点O的坐标为（Xo，Yo，Zo）,空间某条直线上两点A和B的坐标为：(X1,Y1,Z1),(X2，Y2，Z2),设点O在直线AB上的垂足为点N，坐标为(Xn，Yn，Zn)。点N坐标解算过程如下： 首先求出下列向量：   由向量垂直关系（公式1）：   点N在直线AB上，根据向量共线（公式2）：   由公式2得（公式3）：   把公式3式代入公式1式，式中只有一个未知数k，整理化简解出k（公式4）：   把公式4式代入公式3式即得到垂足N的坐标。
二维空间
// 二维空间点到直线的垂足 struct Point { double x,y; } Point GetFootOfPerpendicular( const Point &amp;amp;pt, // 直线外一点 const Point &amp;amp;begin, // 直线开始点 const Point &amp;amp;end) // 直线结束点 { Point retVal; double dx = begin.x - end.x; double dy = begin.y - end.y; if(abs(dx) &amp;lt; 0.00000001 &amp;amp;&amp;amp; abs(dy) &amp;lt; 0.00000001 ) { retVal = begin; return retVal; } double u = (pt.</description>
    </item>
    
    <item>
      <title>[Math]Parabola movement</title>
      <link>https://dawnarc.com/2018/08/mathparabola-movement/</link>
      <pubDate>Wed, 29 Aug 2018 11:58:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/08/mathparabola-movement/</guid>
      <description>keywords：抛物运动、Parabola、重力加速度、Gravitational Speed 、UE4 implement.
header
AStaticMeshActor* TestCube = nullptr; //throw speed UPROPERTY(EditDefaultsOnly) FVector StartForce = FVector(100.f, 100.f, 2000.f); //gravitational acceleration float GravityAcclerator = -980.f; //accumulated movtion time float AccumulateTime = 0.f;  cpp
void ATestTPGameMode::StartPlay() { Super::StartPlay(); //finding the Actor in scene. for (TActorIterator&amp;lt;AStaticMeshActor&amp;gt; Iter(GetWorld()); Iter; ++Iter) { if (Iter-&amp;gt;GetName() == TEXT(&amp;quot;Cube_2&amp;quot;)) { TestCube = *Iter; break; } } } void ATestTPGameMode::Tick(float DeltaSeconds) { Super::Tick(DeltaSeconds); AccumulateTime += DeltaSeconds; //calculate gravitational speed in real time.</description>
    </item>
    
    <item>
      <title>[Math]Orthogonalize(正交化)</title>
      <link>https://dawnarc.com/2018/07/mathorthogonalize%E6%AD%A3%E4%BA%A4%E5%8C%96/</link>
      <pubDate>Mon, 30 Jul 2018 16:58:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/mathorthogonalize%E6%AD%A3%E4%BA%A4%E5%8C%96/</guid>
      <description>格拉姆-施密特正交化
https://zh.wikipedia.org/wiki/%E6%A0%BC%E6%8B%89%E5%A7%86-%E6%96%BD%E5%AF%86%E7%89%B9%E6%AD%A3%E4%BA%A4%E5%8C%96
内积空间
https://zh.wikipedia.org/wiki/%E5%86%85%E7%A7%AF%E7%A9%BA%E9%97%B4
标准正交基
https://zh.wikipedia.org/wiki/%E6%A0%87%E5%87%86%E6%AD%A3%E4%BA%A4%E5%9F%BA
子空间
https://zh.wikipedia.org/wiki/%E5%AD%90%E7%A9%BA%E9%96%93
豪斯霍尔德变换
https://zh.wikipedia.org/wiki/%E8%B1%AA%E6%96%AF%E9%9C%8D%E5%B0%94%E5%BE%B7%E5%8F%98%E6%8D%A2
吉文斯旋转
https://zh.wikipedia.org/wiki/%E5%90%89%E6%96%87%E6%96%AF%E6%97%8B%E8%BD%AC</description>
    </item>
    
    <item>
      <title>[Math]Projectile Motion: Finding the Optimal Launch Angle</title>
      <link>https://dawnarc.com/2018/07/mathprojectile-motion-finding-the-optimal-launch-angle/</link>
      <pubDate>Mon, 23 Jul 2018 18:21:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/07/mathprojectile-motion-finding-the-optimal-launch-angle/</guid>
      <description>If we want to throw a projectile as far as possible, at what angle should it be launched? This paper focuses on how the answer to this question changes depending on the situation.
如果你想尽可能远的抛掷物体，以多大的角度抛出最合适？这篇文章用于分析不同测试环境下而导致的不同答案。
论文地址：Projectile Motion: Finding the Optimal Launch Angle
https://www.whitman.edu/Documents/Academics/Mathematics/2016/Henelsmith.pdf</description>
    </item>
    
    <item>
      <title>[UE4]LoadObject加载UAnimBlueprint失败</title>
      <link>https://dawnarc.com/2018/04/ue4loadobject%E5%8A%A0%E8%BD%BDuanimblueprint%E5%A4%B1%E8%B4%A5/</link>
      <pubDate>Sat, 14 Apr 2018 22:10:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/ue4loadobject%E5%8A%A0%E8%BD%BDuanimblueprint%E5%A4%B1%E8%B4%A5/</guid>
      <description>keywords：UE4、Dynamic Load、Animation Blueprint、LoadObject、动画蓝图
问题现象 假如用以下方式加载动画蓝图：
FString AnimBPStringTest = &amp;quot;AnimBlueprint&#39;/Game/ThirdPerson/Animations/ThirdPerson_AnimBP.ThirdPerson_AnimBP&#39;&amp;quot;; UAnimBlueprint* AnimationBP = LoadObject&amp;lt;UAnimBlueprint&amp;gt;(NULL, *AnimBPStringTest);  在PIE和Standalone模式下都可加载成功，但是一旦打包运行（打包配置中添加了该资源cook）就会加载失败，并提示如下错误：
LogUObjectGlobals:Warning: Failed to find object &#39;AnimBlueprint /Game/ThirdPerson/Animations/ThirdPerson_AnimBP.ThirdPerson_AnimBP&#39;  解决办法 貌似动画蓝图比较特殊，用LoadObject无法加载，如果要获取动画蓝图Class，可以通过如下方式加载：
// get the blueprint class reference from the editor FString AnimClassStringTest = &amp;quot;Class&#39;/Game/mixamo/Heidi/IcloneAnimBP.IcloneAnimBP_C&#39;&amp;quot;; // load the class UClass* AnimationClass = LoadObject&amp;lt;UClass&amp;gt;(NULL, *AnimClassStringTest); if (!AnimationClass) return; // assign the anim blueprint class to your skeletal mesh component Skeletal3DMeshComponent-&amp;gt;SetAnimInstanceClass(AnimationClass);  参考：Why can&amp;rsquo;t i dynamically load an animation BP in a packaged game</description>
    </item>
    
    <item>
      <title>[UE4][线性代数]世界坐标转局部坐标(World Space to Local Space)</title>
      <link>https://dawnarc.com/2018/04/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87world-space-to-local-space/</link>
      <pubDate>Fri, 13 Apr 2018 15:59:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2018/04/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%96%E7%95%8C%E5%9D%90%E6%A0%87%E8%BD%AC%E5%B1%80%E9%83%A8%E5%9D%90%E6%A0%87world-space-to-local-space/</guid>
      <description>keywords：UE4、InverseTransformVector、InverseTransformPosition
实例代码：
//返回摄像机Rotation相对角色Rotation的偏移量Offset FRotator ASBaseCharacter::GetAimOffsets() const { const FVector AimDirWS = GetBaseAimRotation().Vector(); const FVector AimDirLS = ActorToWorld().InverseTransformVectorNoScale(AimDirWS); const FRotator AimRotLS = AimDirLS.Rotation(); return AimRotLS; }  https://github.com/tomlooman/EpicSurvivalGameSeries/blob/4a6ee9a6081529fadbe0f693b2e4e6729d5ec08d/SurvivalGame/Source/SurvivalGame/Private/Player/SBaseCharacter.cpp#L374
如果只是想获取两个Rotation之间的Offset，更简单的办法：
FRotator R1; FRotator R2; FRotator Offset = R2 - R1;  但这种直接相减的方式，返回的结果Rotation，度数可能会小于-180 或 大于 180，需要手动处理范围限定，但是效率远高于 InverseTransformVector。
无欲则刚，关心则乱。----《论语》</description>
    </item>
    
    <item>
      <title>[Math]共轭矩阵、逆矩阵、复矩阵</title>
      <link>https://dawnarc.com/2017/02/math%E5%85%B1%E8%BD%AD%E7%9F%A9%E9%98%B5%E9%80%86%E7%9F%A9%E9%98%B5%E5%A4%8D%E7%9F%A9%E9%98%B5/</link>
      <pubDate>Wed, 22 Feb 2017 14:32:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/math%E5%85%B1%E8%BD%AD%E7%9F%A9%E9%98%B5%E9%80%86%E7%9F%A9%E9%98%B5%E5%A4%8D%E7%9F%A9%E9%98%B5/</guid>
      <description>共轭矩阵
http://baike.baidu.com/item/%E5%85%B1%E8%BD%AD%E7%9F%A9%E9%98%B5
逆矩阵
http://baike.baidu.com/item/%E9%80%86%E7%9F%A9%E9%98%B5
复矩阵
http://baike.baidu.com/item/%E5%A4%8D%E7%9F%A9%E9%98%B5
目察秋毫之末，耳不闻雷霆之声；耳调玉石之声，目不见太山之高。---《淮南子》</description>
    </item>
    
    <item>
      <title>[Math]矩阵乘法</title>
      <link>https://dawnarc.com/2017/02/math%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</link>
      <pubDate>Wed, 22 Feb 2017 14:32:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/math%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95/</guid>
      <description>矩阵乘法
http://baike.baidu.com/view/2455255.htm
矩阵乘法
http://www.cnblogs.com/DreamUp/archive/2010/07/27/1786225.html
目察秋毫之末，耳不闻雷霆之声；耳调玉石之声，目不见太山之高。——《淮南子》</description>
    </item>
    
    <item>
      <title>[Math]两个旋转矩阵（Rotation Matrix）相乘（Multiply）的几何意义</title>
      <link>https://dawnarc.com/2017/02/math%E4%B8%A4%E4%B8%AA%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5rotation-matrix%E7%9B%B8%E4%B9%98multiply%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/</link>
      <pubDate>Thu, 09 Feb 2017 16:48:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/math%E4%B8%A4%E4%B8%AA%E6%97%8B%E8%BD%AC%E7%9F%A9%E9%98%B5rotation-matrix%E7%9B%B8%E4%B9%98multiply%E7%9A%84%E5%87%A0%E4%BD%95%E6%84%8F%E4%B9%89/</guid>
      <description>讲之前，先说下如果两个Rotation相加的意义，比如：
FRotator Rot1(0.f, 90.f, 0.f); FRotator Rot2(90.f,0.f, 0.f); FRotator Result = Rot1 + Rot2;  得到的结果FRotator Result(90.f, 90.f, 0.f)，其意义是： 物体相对空间坐标原点的Rotation为(90.f, 90.f, 0.f)，很好理解。
如果两个Rotation转换为Martix并相乘，比如：
FRotator Rot1(0.f, 90.f, 0.f); FRotator Rot2(90.f,0.f, 0.f); FRotator Result =( FRotationMatrix(Rot1) * FRotationMatrix(Rot2)).Rotator;  得到的结果FRotator Result(0.f, 90.f, 90.f)，其意义是： 先将物体作Rot1旋转，即：Yaw方向（水平平面）旋转90度，然后再假设该物体相对坐标轴原点的旋转量为(0, 0, 0)，即没有作任何旋转，但实际Rotation相对坐标轴原点为(0, 90, 0)；然后再将物体进行Rot2旋转，即Pitch方向（垂直于(90, 0, 0)方向的平面）侧翻90度，因为侧翻90度前假设物体的Rotation是(0, 0, 0)，所以侧翻时所在的平面不再是Yaw=90的平面（垂直于(0, 90, 0)方向），而是Yaw=0的平面（垂直于(90, 0, 0)方向）。没做相关配图，这段话理解起来有点绕，最好用空间思维想象下，可以用手掌比划。
实际应用： 比如空间中有两个物体：A和B，现在要将A旋转至与B相同的朝向，目前只知道A的相对世界坐标的Rotation Rw(90.f,0.f, 0.f)、B相对A（将A的Rotation当做(0, 0, 0)）的Rotation Rr(0.f, 90.f, 0.f)，求A旋转后的世界坐标Rotation。
此时的计算公式就是：
(FRotationMatrix(Rr) * FRotationMatrix(Rw)).Rotator()  注意：矩阵相乘时，两个乘数的前后位置不同则计算的结果也不同，比如上面例子，如果是( FRotationMatrix(Rot2) * FRotationMatrix(Rot1)).</description>
    </item>
    
    <item>
      <title>[Math]什么是“齐次”，“非齐次”，“线性”，“非线性”？</title>
      <link>https://dawnarc.com/2017/02/math%E4%BB%80%E4%B9%88%E6%98%AF%E9%BD%90%E6%AC%A1%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7/</link>
      <pubDate>Thu, 09 Feb 2017 16:48:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/math%E4%BB%80%E4%B9%88%E6%98%AF%E9%BD%90%E6%AC%A1%E9%9D%9E%E9%BD%90%E6%AC%A1%E7%BA%BF%E6%80%A7%E9%9D%9E%E7%BA%BF%E6%80%A7/</guid>
      <description>什么是“齐次”，“非齐次”，“线性”，“非线性”？
https://www.zhihu.com/question/19816504
齐次坐标和矩阵变换
http://www.cnblogs.com/lizhengjin/archive/2010/11/07/1871055.html
计算机图形学：求齐次坐标变换矩阵
https://zhidao.baidu.com/question/132223547.html
HOMOGENEOUS TRANSFORMATION MATRICES
http://www.silcom.com/~barnowl/HTransf.htm
天道何亲，惟德之亲；鬼神何灵，因人而灵。---刘基《司马季主论卜》</description>
    </item>
    
    <item>
      <title>[Math]The Mathematics of the 3D Rotation Matrix</title>
      <link>https://dawnarc.com/2017/02/maththe-mathematics-of-the-3d-rotation-matrix/</link>
      <pubDate>Thu, 09 Feb 2017 12:10:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2017/02/maththe-mathematics-of-the-3d-rotation-matrix/</guid>
      <description>The Mathematics of the 3D Rotation Matrix
https://www.fastgraph.com/makegames/3drotation/
How to combine rotation in 2 axis into one matrix
http://computergraphics.stackexchange.com/questions/1608/how-to-combine-rotation-in-2-axis-into-one-matrix
Rotation matrix
https://en.wikipedia.org/wiki/Rotation_matrix
云山苍苍，江水泱泱，先生之风，山高水长。---范仲淹《严先生祠堂记》</description>
    </item>
    
    <item>
      <title>[UE4]Lerp函数的计算公式</title>
      <link>https://dawnarc.com/2016/11/ue4lerp%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</link>
      <pubDate>Sat, 26 Nov 2016 18:17:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/11/ue4lerp%E5%87%BD%E6%95%B0%E7%9A%84%E8%AE%A1%E7%AE%97%E5%85%AC%E5%BC%8F/</guid>
      <description>UnrealMathUnlity.h：
/** Performs a linear interpolation between two values, Alpha ranges from 0-1 */ template&amp;lt; class T, class U &amp;gt; static FORCEINLINE_DEBUGGABLE T Lerp( const T&amp;amp; A, const T&amp;amp; B, const U&amp;amp; Alpha ) { return (T)(A + Alpha * (B-A)); } /** Performs a linear interpolation between two values, Alpha ranges from 0-1. Handles full numeric range of T */ template&amp;lt; class T &amp;gt; static FORCEINLINE_DEBUGGABLE T LerpStable( const T&amp;amp; A, const T&amp;amp; B, double Alpha ) { return (T)((A * (1.</description>
    </item>
    
    <item>
      <title>[UE4][线性代数]向量积、外积、叉积</title>
      <link>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%90%91%E9%87%8F%E7%A7%AF%E5%A4%96%E7%A7%AF%E5%8F%89%E7%A7%AF/</link>
      <pubDate>Sat, 23 Jul 2016 19:19:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%90%91%E9%87%8F%E7%A7%AF%E5%A4%96%E7%A7%AF%E5%8F%89%E7%A7%AF/</guid>
      <description>叉积 http://baike.baidu.com/view/973423.htm
点积 http://baike.baidu.com/view/2744555.htm
UE4的叉积（向量积、外积）函数：
FVector::CrossProduct()  UE4的点积（数量积、内积）函数：
FVector::DotProduct()  具体代码示例
FVector V1(100.f, 0.f, 0.f); FVector V2 = FRotator(0.f, 30.f, 0.f).RotateVector(V1); FVector V3 = FRotator(0.f, 45.f, 0.f).RotateVector(V1); FVector V4 = FRotator(0.f, 60.f, 0.f).RotateVector(V1); float d1 = FVector::DotProduct(V2, V3); float d2 = FVector::DotProduct(V3, V2); float d3 = FVector::DotProduct(V3, V4); float d4 = FVector::DotProduct(V2, V4);  其中各个值为：
V2 = (86.6f, 50.f, 0.f) V3 = (70.7f, 70.7f, 0.f) V4 = (50.f, 86.6f, 0.f) d1 = 9659.</description>
    </item>
    
    <item>
      <title>[UE4][线性代数]基于某点向某方向上投射指定距离后的坐标计算</title>
      <link>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E4%BA%8E%E6%9F%90%E7%82%B9%E5%90%91%E6%9F%90%E6%96%B9%E5%90%91%E4%B8%8A%E6%8A%95%E5%B0%84%E6%8C%87%E5%AE%9A%E8%B7%9D%E7%A6%BB%E5%90%8E%E7%9A%84%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97/</link>
      <pubDate>Wed, 06 Jul 2016 19:54:40 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%9F%BA%E4%BA%8E%E6%9F%90%E7%82%B9%E5%90%91%E6%9F%90%E6%96%B9%E5%90%91%E4%B8%8A%E6%8A%95%E5%B0%84%E6%8C%87%E5%AE%9A%E8%B7%9D%E7%A6%BB%E5%90%8E%E7%9A%84%E5%9D%90%E6%A0%87%E8%AE%A1%E7%AE%97/</guid>
      <description>代码：
float Len = FMath::Sqrt(100 * 100 + 100 * 100); FVector Loc = FVector(100.f, 100.f, 0.f) + FRotator(0.f, 45.f, 0.f).Vector() * Len;  结果：
Loc = {X=200.f, Y=200.f, Z=0.f}  =================================
例子2：
float Len = FMath::Sqrt(100 * 100 + 100 * 100); FVector Loc1 = FVector(0.f, 0.f, 0.f) + FRotator(0.f, 45.f, 0.f).Vector() * Len; FVector Loc2 = FVector(0.f, 0.f, 0.f) + FRotator(0.f, 135.f, 0.f).Vector() * Len; FVector Loc3 = FVector(0.</description>
    </item>
    
    <item>
      <title>[UE4][线性代数]已知方向向量，求该向量与空间坐标轴的夹角</title>
      <link>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%B7%B2%E7%9F%A5%E6%96%B9%E5%90%91%E5%90%91%E9%87%8F%E6%B1%82%E8%AF%A5%E5%90%91%E9%87%8F%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E5%A4%B9%E8%A7%92/</link>
      <pubDate>Wed, 06 Jul 2016 17:30:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/07/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%B7%B2%E7%9F%A5%E6%96%B9%E5%90%91%E5%90%91%E9%87%8F%E6%B1%82%E8%AF%A5%E5%90%91%E9%87%8F%E4%B8%8E%E7%A9%BA%E9%97%B4%E5%9D%90%E6%A0%87%E8%BD%B4%E7%9A%84%E5%A4%B9%E8%A7%92/</guid>
      <description>原始的数学公式不列举了，需要的话找个Math库看下源码。这里以UE4的API说明：
情况一：已知两个坐标点，求连线与空间坐标的夹角 已知空间中两个点FVector V1, V2，方向向量V3 = V2 - V1，求V3与空间坐标的夹角：
FRotator R = (V2 - V1).Rotation();  情况二：单个向量与世界坐标的夹角 已知方向向量Vector V1，求V1与空间坐标轴的夹角Rotator R1：即将Vector转换为Rotator
FRotator R1 = FVector(100.f, 100.f, 0.f).Rotation(); FRotator R2 = FVector(-100.f, -100.f, 0.f).Rotation(); FRotator R3 = FVector(100.f, 0.f, 0.f).Rotation(); FRotator R4 = FVector(0.f, 100.f, 0.f).Rotation();  结果分别是：
R1 = {Pitch=0.0 Yaw=45.0 Roll=0.0 } R2 = {Pitch=0.0 Yaw=-135.0 Roll=0.0 } R3 = {Pitch=0.0 Yaw=0.0 Roll=0.0 } R4 = {Pitch=0.0 Yaw=90.0 Roll=0.0 }  FVector::Rotation()函数的内部实现（局部）：</description>
    </item>
    
    <item>
      <title>[Math]如何检测某个点是否在多边形内部或者直线上</title>
      <link>https://dawnarc.com/2016/06/math%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8%E6%88%96%E8%80%85%E7%9B%B4%E7%BA%BF%E4%B8%8A/</link>
      <pubDate>Thu, 23 Jun 2016 19:14:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/math%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E5%A4%9A%E8%BE%B9%E5%BD%A2%E5%86%85%E9%83%A8%E6%88%96%E8%80%85%E7%9B%B4%E7%BA%BF%E4%B8%8A/</guid>
      <description>点在多边形内的判别方法 int pnpoly(int nvert, float *vertx, float *verty, float testx, float testy) { int i, j, c = 0; for (i = 0, j = nvert-1; i &amp;lt; nvert; j = i++) { if (((verty[i] &amp;gt; testy) != (verty[j] &amp;gt; testy)) &amp;amp;&amp;amp; (testx &amp;lt; (vertx[j] - vertx[i]) * (testy - verty[i]) / (verty[j] - verty[i]) + vertx[i]) ) { c = !c; } } return c; }  Arguments</description>
    </item>
    
    <item>
      <title>[UE4][线性代数]如何检测某个点是否在矩形范围内</title>
      <link>https://dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E8%8C%83%E5%9B%B4%E5%86%85/</link>
      <pubDate>Thu, 23 Jun 2016 15:15:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E5%A6%82%E4%BD%95%E6%A3%80%E6%B5%8B%E6%9F%90%E4%B8%AA%E7%82%B9%E6%98%AF%E5%90%A6%E5%9C%A8%E7%9F%A9%E5%BD%A2%E8%8C%83%E5%9B%B4%E5%86%85/</guid>
      <description>代码：
FBox2D::IsInside(const FVector2D&amp;amp; TestPoint) FBox::IsInside(const FVector&amp;amp; TestPoint) FIntRect::Contains( FIntPoint P )  </description>
    </item>
    
    <item>
      <title>[UE4][线性代数]物体围绕某个点旋转一定角度</title>
      <link>https://dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%89%A9%E4%BD%93%E5%9B%B4%E7%BB%95%E6%9F%90%E4%B8%AA%E7%82%B9%E6%97%8B%E8%BD%AC%E4%B8%80%E5%AE%9A%E8%A7%92%E5%BA%A6/</link>
      <pubDate>Wed, 08 Jun 2016 18:15:02 +0800</pubDate>
      
      <guid>https://dawnarc.com/2016/06/ue4%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E7%89%A9%E4%BD%93%E5%9B%B4%E7%BB%95%E6%9F%90%E4%B8%AA%E7%82%B9%E6%97%8B%E8%BD%AC%E4%B8%80%E5%AE%9A%E8%A7%92%E5%BA%A6/</guid>
      <description>三角函数公式 2D上的点围绕某另一个点旋转： If you rotate point (px, py) around point (ox, oy) by angle theta you&amp;rsquo;ll get:
p&#39;x = cos(theta) * (px-ox) - sin(theta) * (py-oy) + ox p&#39;y = sin(theta) * (px-ox) + cos(theta) * (py-oy) + oy  this is an easy way to rotate a point in 2D.
3D上的点围绕某另一个点旋转
http://stackoverflow.com/questions/13275719/rotate-a-3d-point-around-another-one
Try to use vector math. decide in which order you rotate, first along x, then along y perhaps.</description>
    </item>
    
  </channel>
</rss>